#!/bin/sh /etc/rc.common
# shellcheck disable=SC3043,SC2018,SC3020,SC1090,SC3045,SC2155,SC2015,SC3057,SC3044,SC2016,SC3003

# adblock-lean - powerful and ultra efficient adblocking with dnsmasq on OpenWrt
# Project homepage: https://github.com/lynxthecat/adblock-lean
# ABL_VERSION=dev

START=99
STOP=04

# Authors: @Lynx and @Wizballs (OpenWrt forum)
# Contributors: @antonk; @dave14305 (OpenWrt forum)

# global exit codes:
# 0 - Success
# 1 - Error
# 254 - Failed to acquire lock

# special variables for luci have the prefix 'luci_'

# expects that the RPC script for luci UI is named specifically 'luci.adblock-lean'

# get return value of built-in actions
action_rv="${?}"

LC_ALL=C
DEFAULT_IFS='	 
'
_NL_='
'
IFS="${DEFAULT_IFS}"

if [ -t 0 ]
then
	MSGS_DEST=/dev/tty
else
	MSGS_DEST=/dev/null
fi

ABL_DIR=/var/run/adblock-lean
ABL_LIB_DIR=/usr/lib/adblock-lean
ABL_CONFIG_DIR=/etc/adblock-lean
ABL_PID_DIR=/tmp/adblock-lean
ABL_UPD_DIR="/var/run/adblock-lean-update"

ABL_SERVICE_PATH=/etc/init.d/adblock-lean
ABL_LIB_FILES="${ABL_LIB_DIR}/abl-lib.sh ${ABL_LIB_DIR}/abl-process.sh"
ABL_EXTRA_FILES="" # may be useful in the future

ABL_CONFIG_FILE=${ABL_CONFIG_DIR}/config
CONFIG_FORMAT=v6

PID_FILE="${ABL_PID_DIR}/adblock-lean.pid"

ABL_UPDATE_LOG_FILE=/var/log/abl_update.log
ABL_SESSION_LOG_FILE=/var/log/abl_session.log
UCL_ERR_FILE="${ABL_DIR}/uclient-fetch_err"

ABL_CRON_CMD="/etc/init.d/adblock-lean start"

ABL_GH_URL_API=https://api.github.com/repos/lynxthecat/adblock-lean

export PATH=/usr/sbin:/usr/bin:/sbin:/bin

EXTRA_COMMANDS="setup version status pause resume gen_stats select_dnsmasq_instance gen_config upd_cron_job print_log update uninstall"
EXTRA_HELP="
adblock-lean custom commands:
	version                  print adblock-lean version
	setup                    run automated setup for adblock-lean
	status                   check dnsmasq and entries count of existing blocklist
	pause                    pause adblock-lean
	resume                   resume adblock-lean
	gen_stats                generate dnsmasq stats for system log
	select_dnsmasq_instance  analyze dnsmasq instances and set dnsmasq conf-dir
	gen_config               generate default config based on one of the pre-defined presets
	upd_cron_job             create cron job for adblock-lean with schedule set in the config option 'cron_schedule'.
	                         if config option set to 'disable', remove existing cron job if any
	print_log                print most recent session log
	update                   update adblock-lean to the latest version
	uninstall                uninstall adblock-lean, remove all adblock-lean-related files and settings"

# silence shellcheck warnings
: "${action:=}" "${action_rv}" "${EXTRA_COMMANDS}" "${EXTRA_HELP}" "${boot_start_delay_s:=}" "${purple}" "${TAB}" "${CR_LF}"
: "${AWK_CMD}" "${SORT_CMD}"
: "${luci_log}" "${luci_pid_action}" "${luci_errors}" "${luci_dnsmasq_status}"
: "${luci_good_line_count}" "${luci_update_status}" "${luci_pkgs_install_failed}" "${luci_cron_job_creation_failed}"


### UTILITY FUNCTIONS

check_util()
{
	command -v "${1}" 1>/dev/null
}

# sets global variables for colors, tab delimiter and cr_lf
set_ansi()
{
	local IFS=" "
	# shellcheck disable=SC2046
	set -- $(printf '\033[0;31m \033[0;32m \033[1;34m \033[1;33m \033[0;35m \033[0m \35 \t \r')
	red="${1}" green="${2}" blue="${3}" yellow="${4}" purple="${5}" n_c="${6}" _DELIM_="${7}" TAB="${8}" CR_LF="${9}${_NL_}"
}

# checks if string $1 is included in newline-separated list $2
# if $3 is specified, uses the value as list delimiter
# result via return status
is_included() {
	local delim="${3:-"${_NL_}"}"
	case "$2" in
		"$1"|"$1${delim}"*|*"${delim}$1"|*"${delim}$1${delim}"*)
			return 0 ;;
		*)
			return 1
	esac
}

# adds a string to a newline-separated list if it's not included yet
# 1 - name of var which contains the list
# 2 - new value
# 3 - (optional) list delimiter (instead of newline)
# returns 1 if bad var name, 0 otherwise
add2list() {
	case "${1}" in *[!A-Za-z0-9_]*)
		return 1
	esac

	local curr_list delim="${3:-"${_NL_}"}" fs=
	eval "curr_list=\"\${${1}}\""
	is_included "${2}" "${curr_list}" "${delim}" && return 0
	case "${curr_list}" in
		'') fs='' ;;
		*) fs="${delim}" ;;
	esac
	eval "${1}=\"\${${1}}${fs}${2}\""
	:
}

get_md5()
{
	md5sum "${1}" | cut -d' ' -f1
}

# 0 - (optional) '-p'
# 1 - path
try_mkdir()
{
	local p=
	[ "${1}" = '-p' ] && { p='-p'; shift; }
	[ -d "${1}" ] && return 0
	mkdir ${p} "${1}" || { reg_failure "Failed to create directory '${1}'."; return 1; }
	:
}

# asks the user to pick an option
# 1 - input in the format 'a|b|c'
# output via $REPLY
pick_opt()
{
	update_pid_action "Waiting for user input in console" || return 1
	while :
	do
		printf %s "$1: " 1>${MSGS_DEST}
		read -r REPLY
		case "$REPLY" in *[!A-Za-z0-9_]*) printf '\n%s\n\n' "Please enter $1" 1>${MSGS_DEST}; continue; esac
		eval "case \"$REPLY\" in 
				$1) return 0 ;;
				*) printf '\n%s\n\n' \"Please enter $1\" 1>${MSGS_DEST}
			esac"
	done
}


### HELPER FUNCTIONS

rc_disable()
{
	rm -f /etc/rc.d/S${START}adblock-lean /etc/rc.d/K${STOP}adblock-lean
}

rc_enable()
{
	local err=1
		ln -sf "../init.d/adblock-lean" "/etc/rc.d/S${START}adblock-lean" && err=0
		ln -sf "../init.d/adblock-lean" "/etc/rc.d/K${STOP}adblock-lean" && err=0
	return $err
}

rc_enabled()
{
	[ -L "/etc/rc.d/S${START}adblock-lean" ] &&
	[ -L "/etc/rc.d/K${STOP}adblock-lean" ]
}

# sets $AWK_CMD, $SED_CMD, $SORT_CMD
detect_utils() {
	if type gawk &> /dev/null
	then
		AWK_CMD="gawk"
	else
		AWK_CMD="busybox awk"
	fi

	if sed --version 2>/dev/null | grep -qe '(GNU sed)'
	then
		SED_CMD="sed"
	else
		SED_CMD="busybox sed"
	fi

	if sort --version 2>/dev/null | grep -qe coreutils
	then
		SORT_CMD="sort"
	else
		SORT_CMD="busybox sort"
	fi
	:
}

# prints each argument into a separate line
print_msg()
{
	local m
	for m in "${@}"
	do
		printf '%s\n' "${m}" > "$MSGS_DEST"
	done
}

# logs each message argument separately and prints to a separate line
# optional arguments: '-err', '-warn', '-[color]'
log_msg()
{
	local m msgs='' msgs_prefix='' _arg err_l=info color=

	local IFS="${DEFAULT_IFS}"
	for _arg in "$@"
	do
		case "${_arg}" in
			"-err") err_l=err color="${red}" msgs_prefix="Error: " ;;
			"-warn") err_l=warn color="${yellow}" msgs_prefix="Warning: " ;;
			-blue|-red|-green|-purple|-yellow) eval "color=\"\${${_arg#-}}\"" ;;
			'') msgs="${msgs}dummy${_DELIM_}" ;;
			*) msgs="${msgs}${msgs_prefix}${_arg}${_DELIM_}"; [ -n "${msgs_prefix}" ] && msgs_prefix=
		esac
	done
	msgs="${msgs%"${_DELIM_}"}"
	IFS="${_DELIM_}"

	for m in ${msgs}
	do
		case "${m}" in
			dummy) echo ;;
			*)
				print_msg "${color}${m}${n_c}"
				logger -t adblock-lean -p user."${err_l}" "${m}"
				write_log_file "${m}" "${err_l}"
		esac
	done
	:
}

# 1 - msg
# 2 - err level
write_log_file()
{
	[ -n "${LOG_FILE}" ] && { printf '['; date +'%b %d %Y, %H:%M:%S' | tr -d '\n'; printf '] %s\n' "${2:-info}: ${1}"; } >> "${LOG_FILE}"
}

# exit with code ${1}
# if function 'abl_luci_exit' is defined, execute it before exit
cleanup_and_exit()
{
	trap - INT TERM EXIT
	[ -n "${CLEANUP_REQ}" ] && rm -rf "${ABL_DIR}"
	[ -n "${LOCK_REQ}" ] && rm_lock
	local recent_log=
	[ -n "${LOG_FILE}" ] && [ -s "${LOG_FILE}" ] && read -rd '' recent_log < "${LOG_FILE}"
	luci_log="${recent_log}"
	if [ -z "${luci_sourced}" ] && [ -n "${failure_msg}" ] && [ -n "${custom_scr_sourced}" ] && check_util report_failure
	then
		[ -n "${recent_log}" ] && failure_msg="${failure_msg}${_NL_}${_NL_}Session log:${_NL_}${recent_log}"
		report_failure "${failure_msg}"
	fi
	[ -n "${luci_sourced}" ] && abl_luci_exit "${1}"
	exit "${1}"
}

# shellcheck disable=SC2120
# 1 - (optional) '-nostop' to not call stop on failure
restart_dnsmasq()
{
	reg_action -blue "Restarting dnsmasq." || return 1

	/etc/init.d/dnsmasq restart &> /dev/null ||
	{
		reg_failure "Failed to restart dnsmasq."
		[ "${ABL_CMD}" != stop ] && [ "${1}" != '-nostop' ] && stop 1 -noexit
		return 1
	}

	reg_action -blue "Waiting for dnsmasq initialization." || return 1
	local dnsmasq_ok=
	for i in $(seq 1 60)
	do
		nslookup localhost 127.0.0.1 &> /dev/null && { dnsmasq_ok=1; break; }
		sleep 1;
	done

	[ -n "$dnsmasq_ok" ] ||
	{
		reg_failure "dnsmasq initialization failed."
		[ "${ABL_CMD}" != stop ] && [ "${1}" != '-nostop' ] && stop 1 -noexit
		return 1
	}

	log_msg -green "Restart of dnsmasq completed."
	:
}

# args:
# 1 - (optional) -f to skip check for existing lock
# 1/2 - action to write to the pid file
#
# return codes:
# 0 - success
# 1 - error
# 254 - lock file already exists
mk_lock()
{
	local me="mk_lock"
	if [ "${1}" != '-f' ]
	then
		check_lock
		case ${?} in
			1) return 1 ;;
			2)
				report_pid_action
				log_msg -yellow "Refusing to open another instance."
				return 254
		esac
	else
		shift
	fi

	[ -z "${1%.}" ] && { reg_failure "${me}: pid action is unspecified."; return 1; }
	[ -z "${PID_FILE}" ] && { reg_failure "${me}: \${PID_FILE} variable is unset."; return 1; }

	try_mkdir -p "${ABL_PID_DIR}" || return 1
	printf '%s\n' "${$} ${1%.}" > "${PID_FILE}" || { reg_failure "${me}: Failed to write to pid file '${PID_FILE}'."; return 1; }
	:
}

# return codes:
# 0 - no lock
# 1 - error
# 2 - lock file exists and belongs to another PID
# 3 - lock file belongs to current PID
check_lock()
{
	unset LOCK_PID PID_ABL_CMD
	[ -z "${PID_FILE}" ] && { reg_failure "\${PID_FILE} variable is unset."; return 1; }
	[ ! -f "${PID_FILE}" ] && return 0
	if IFS=" " read -r LOCK_PID PID_ABL_CMD < "${PID_FILE}"
	then
		case "${LOCK_PID}" in
			"${$}") return 3 ;;
			*[!0-9]*) reg_failure "pid file '${PID_FILE}' contains unexpected string '${LOCK_PID}'."; return 1 ;;
			*) kill -0 "${LOCK_PID}" 2>/dev/null && return 2
		esac
	else
		reg_failure "Failed to read the pid file '${PID_FILE}'."
		return 1
	fi

	log_msg -warn "Detected stale pid file '${PID_FILE}' for PID ${LOCK_PID}. Removing."
	rm_lock || return 1
	:
}

rm_lock()
{
	if [ -f "${PID_FILE}" ]
	then
		rm -f "${PID_FILE}" || { reg_failure "Failed to delete the pid file '${PID_FILE}'."; return 1; }
	fi
	:
}

# updates the pid file with a new action
# 1 - new action
update_pid_action() {
	check_lock
	case ${?} in
		3) ;;
		1) return 1 ;;
		2) reg_failure "update_pid_action(): pid file '${PID_FILE}' has unexpected pid '${LOCK_PID}'."; return 1 ;;
		0) return 0
	esac
	mk_lock -f "${1}"
	return ${?}
}

report_pid_action()
{
	local reported_pid="unknown PID"
	[ -n "${LOCK_PID}" ] && reported_pid="PID ${LOCK_PID}"
	: "${PID_ABL_CMD:="unknown action"}"
	print_msg "adblock-lean (${reported_pid}) is performing action '${PID_ABL_CMD}'."
	luci_pid_action=${PID_ABL_CMD}
	:
}

# (optional) -nolog
# (optional) -[color]
# other args - action
reg_action()
{
	local arg msg='' nolog='' color=''
	for arg in "$@"
	do
		case "${arg}" in
			-nolog) nolog=1 ;;
			-blue|-red|-green|-purple|-yellow) color="${arg}" ;;
			*) msg="${msg}${arg} "
		esac
	done

	[ -z "${nolog}" ] && log_msg "" ${color} "${msg% }"
	if [ -n "${LOCK_REQ}" ]
	then
		update_pid_action "${msg% }" || return 1
	fi
	:
}

reg_failure()
{
	log_msg -err "" "${1}"
	failure_msg="${failure_msg}${1}${_NL_}"
	luci_errors="${failure_msg}"
}

log_success()
{
	log_msg "${1}"
	if [ -n "${custom_scr_sourced}" ] && check_util report_success
	then
		report_success "${1}"
	fi
}

# kills any running adblock-lean instances
kill_abl_pids()
{
	local _killed _p _pid child_pid IFS=$'\n' k_attempt=0
	while :
	do
		k_attempt=$((k_attempt+1))
		_killed=
		for _p in $(pgrep -fa "(/etc/rc.common /etc/(rc.d/S${START}adblock-lean|init.d/adblock-lean)|luci.adblock-lean)")
		do
			_pid="${_p%% *}"
			case ${_pid} in "${$}"|*[!0-9]*) continue; esac
			kill "${_pid}" 2>/dev/null
			for child_pid in $(pgrep -P "${_pid}")
			do
				kill "${child_pid}" 2>/dev/null
			done
			_killed=1
		done
		[ -z "${_killed}" ] || [ ${k_attempt} -gt 10 ] && break
		sleep 1
	done
	:
}

# return codes:
# 0 - running
# 1,2 - (reserved)
# 3 - paused
# 4 - stopped
get_abl_run_state()
{
	local f
	for f in "${DNSMASQ_CONF_D}/.abl-blocklist.gz" "${DNSMASQ_CONF_D}/abl-blocklist"
	do
		[ -f "${f}" ] && return 0
	done

	[ -f "${ABL_DIR}/prev_blocklist.gz" ] && return 3
	return 4
}

# 1 (optional) - libs directory
# 2 (optional) - service directory
check_libs()
{
	local lib_file service_file service_version lib_version
	local libs_dir="${1:-"${ABL_LIB_DIR}"}" service_dir="${2:-"${ABL_SERVICE_PATH%/*}"}"
	service_file="${service_dir}/adblock-lean"
	get_abl_version "${service_file}" service_version
	for lib_file in ${ABL_LIB_FILES}
	do
		lib_file="${libs_dir}/${lib_file##*/}"
		if [ -s "${lib_file}" ]
		then
			get_abl_version "${lib_file}" lib_version
			if [ "${lib_version}" = "${service_version}" ]
			then
				continue
			else
				log_msg -warn "Version mismatch between ${service_file} ('${service_version}') and ${lib_file} ('${lib_version}')."
			fi
		else
			log_msg -warn "adblock-lean library files are missing."
		fi
		return 1
	done
	:
}

# 1 (optional) - libs directory
# 2 (optional) - service directory
source_libs()
{
	[ -n "${LIBS_SOURCED}" ] && return 0

	local file libs_dir="${1:-"${ABL_LIB_DIR}"}" service_dir="${2:-"${ABL_SERVICE_PATH%/*}"}" libs_missing='' libs_source_failed=''
	if ! check_libs "${libs_dir}" "${service_dir}"
	then
		log_msg "Please run 'sh /etc/init.d/adblock-lean update -f' to fetch required files."
		return 1
	fi

	# source libs
	for file in ${ABL_LIB_FILES}
	do
		file="${file##*/}"
		[ -f "${libs_dir}/${file}" ] || { libs_source_failed=1 libs_missing=1; break; }
		. "${libs_dir}/${file}" || { libs_source_failed=1; break; }
	done

	[ -n "${libs_source_failed}" ] &&
	{
		[ -n "${libs_missing}" ] && reg_failure "Missing library scripts."
		reg_failure "Failed to source library scripts."
		return 1
	}
	LIBS_SOURCED=1
	:
}

# args: 1 - (optional) schedule
# return codes:
# 0 - cron job with same schedule exists
# 1 - error
# 2 - cron job with a different schedule exists
# 3 - cron job doesn't exist
get_curr_crontab()
{
	local curr_cron
	curr_cron="$(crontab -u root -l 2>/dev/null)" || { reg_failure "get_curr_crontab: Failed to read crontab."; return 1; }
	printf '%s\n' "${curr_cron}"

	# check if adblock-lean cron job with same schedule exists
	case "${curr_cron}" in
		*"${cron_schedule}"*"${ABL_CRON_CMD}"*) return 0 ;;
		*"${ABL_CRON_CMD}"*) return 2 ;;
		*) return 3 ;;
	esac
}

rm_cron_job()
{
	local curr_cron
	crontab -u root -l 1>/dev/null 2>/dev/null || return 0
	curr_cron="$(get_curr_crontab)"
	case ${?} in
		1) return 1 ;;
		3) return 0
	esac

	log_msg -purple "" "Removing cron job for adblock-lean."
	printf '%s\n' "${curr_cron}" | ${SED_CMD} '/adblock-lean start/d;/^$/d' | crontab -u root - ||
		{ reg_failure "Failed to update crontab."; return 1; }
	:
}


### Commands init

init_command()
{
	ABL_CMD="${1}"
	local config_req='' work_dir_req='' kill_req='' init_action_msg=''

	# detect if sourced from external RPC script for luci, depends on abl_luci_exit() being defined
	luci_sourced=
	check_util "abl_luci_exit" && luci_sourced=1

	DO_DIALOGS=
	[ -z "${luci_skip_dialogs}" ] && [ "${MSGS_DEST}" = "/dev/tty" ] && DO_DIALOGS=1

	if [ -n "${UPD_SOURCED}" ]
	then
		trap 'exit 1' INT TERM
	else
		trap 'cleanup_and_exit 1' INT TERM
		trap 'cleanup_and_exit ${?}' EXIT
	fi

	# set requirements
	case ${ABL_CMD} in
		help|enabled|enable|disable|print_log|'') ;;
		gen_stats) ;;
		status) libs_req=1 work_dir_req=1 config_req=1 ;;
		upd_cron_job) libs_req=1 config_req=1 ;;
		setup|gen_config) libs_req=1 LOCK_REQ=1 ;;
		boot) libs_req=1 config_req=1 ;;
		pause) libs_req=1 work_dir_req=1 config_req=1 LOCK_REQ=1 ;;
		start|resume) libs_req=1 work_dir_req=1 config_req=1 CLEANUP_REQ=1 LOCK_REQ=1 ;;
		stop)
			init_action_msg="Stopping adblock-lean."
			reg_action -purple "${init_action_msg}" || exit 1
			libs_req=1 kill_req=1 CLEANUP_REQ=1 LOCK_REQ=1 ;;
		select_dnsmasq_instance)
			libs_req=1 LOCK_REQ=1
			[ "${action}" = select_dnsmasq_instance ] && config_req=1 # require config when called directly
			;;
		reload|restart) reg_action -purple "Restarting adblock-lean." || exit 1 ;;
		update) work_dir_req=1 CLEANUP_REQ=1 LOCK_REQ=1 ;;
		*) reg_failure "Invalid action '${ABL_CMD}'."; exit 1
	esac

	# source library scripts
	if [ -n "${libs_req}" ]
	then
		source_libs || exit 1
	fi

	# report installed utils
	if [ "${ABL_CMD}" = start ]
	then
		detect_pkg_manager
		report_utils
	fi

	# kill pids if needed
	if [ -n "${kill_req}" ]
	then
		kill_abl_pids
		check_lock
		case ${?} in
			1) exit 1 ;;
			2)
				reg_failure "Failed to kill running adblock-lean processes."
				unset LOCK_REQ CLEANUP_REQ
				exit 1
		esac
	fi

	# register lock status at init
	check_lock
	local init_lock_status=${?}

	# make lock if needed
	if [ -n "${LOCK_REQ}" ]
	then
		mk_lock "${ABL_CMD}" || { local rv=${?}; unset LOCK_REQ CLEANUP_REQ; exit ${rv}; }
	fi

	# enable writing session log if we have the lock
	LOG_FILE=
	case ${init_lock_status} in 0|3)
		LOG_FILE="${ABL_SESSION_LOG_FILE}"
		[ "${ABL_CMD}" = update ] && LOG_FILE="${ABL_UPDATE_LOG_FILE}"
	esac

	# if creating new session, rotate the old session log file
	[ "${init_lock_status}" = 0 ] && [ -n "${LOG_FILE}" ] && [ -f "${LOG_FILE}" ] && mv "${LOG_FILE}" "${LOG_FILE}.0"

	[ -n "${init_action_msg}" ] && write_log_file "${init_action_msg}" "info"

	[ -n "${work_dir_req}" ] && { try_mkdir -p "${ABL_DIR}" || exit 1; }

	if [ -n "${config_req}" ] && [ -z "${CONFIG_LOADED}" ]
	then
		load_config || { reg_failure "Failed to load config."; exit 1; }
		CONFIG_LOADED=1
	fi

	# check dnsmasq, source custom script
	case ${ABL_CMD} in
		start|pause|resume)
			check_dnsmasq_instance "${DNSMASQ_INSTANCE}" || exit 1
			if [ -n "${custom_script}" ]
			then
				custom_scr_sourced=
				[ -f "${custom_script}" ] && . "${custom_script}" && custom_scr_sourced=1 ||
					reg_failure "Custom script '${custom_script}' doesn't exist or it returned an error."
			fi
	esac

	:
}

# get version of adblock-lean file $1
# assign version to var $2, update channel to var $3
get_abl_version()
{
	unset "${2}" "${3:-dummy}"
	local gv_ver_string gv_version gv_upd_channel
	gv_ver_string="$(${SED_CMD} -n '/^\s*#\s*ABL_VERSION=/{s/^\s*#\s*ABL_VERSION=//;s/\s*$//;p;q;}' "${1}")"
	gv_version="${gv_ver_string##*_}"
	gv_upd_channel="${gv_ver_string%"_${gv_version}"}"
	: "${gv_upd_channel}" # silence shellcheck warning
	eval "${2}"='${gv_version}'
	[ -n "${3}" ] && eval "${3}"='${gv_upd_channel}'
}

# Get GitHub ref and tarball url for specified version
# 1 - [latest|snapshot|v<version>|tag=<github_tag>|commit=<commit_hash>]
# Output via variables:
#   $2 - github ref, $3 - tarball url, $4 - update channel
get_gh_ref_data()
{
	local me=get_gh_ref_data ref_fetch_url jsonfilter_ptrn commit version="${1}"
	local gh_ref=''  gh_channel=''
	unset "${2}" "${3}" "${4}"

	case "${version}" in
		snapshot)
			ref_fetch_url="${ABL_GH_URL_API}/commits/master"
			jsonfilter_ptrn='@.sha' # latest commit is first on the list
			gh_channel=snapshot ;;
		latest)
			ref_fetch_url="${ABL_GH_URL_API}/releases"
			jsonfilter_ptrn='@[@.prerelease=false]' # ignore pre-releases
			gh_channel=release ;;
		v[0-9]*)
			gh_ref="${version}"
			gh_channel=release ;;
		tag=*)
			gh_ref="${version#tag=}"
			gh_channel=tag ;;
		commit=*)
			commit="${version#commit=}"
			gh_ref="${commit%"${commit#???????}"}" # trim commit hash to 7 characters
			gh_channel=commit ;;
		*) reg_failure "${me}: invalid version '${version}'."; return 1
	esac

	if [ -n "${ref_fetch_url}" ]
	then
		# Get ref for latest/snapshot
		log_msg -blue "Getting GitHub ref for ${version} version of adblock-lean."
		gh_ref="$(
			uclient-fetch -q "${ref_fetch_url}" -O - 2> "${UCL_ERR_FILE}" |
			jsonfilter -e "${jsonfilter_ptrn}" |
			{
				case "${version}" in
					snapshot) head -c7 ;;
					latest)
						jsonfilter -a -e '@[@.target_commitish="master"].tag_name' | # get latest tag for master
						head -n1
				esac
				cat 1>/dev/null
			}
		)"
	fi

	# validate resulting ref
	case "${gh_ref}" in
		''|*[!a-zA-Z0-9._-]*) reg_failure "${me}: failed to get GitHub ref for version '${version}'."; return 1
	esac

	eval "${2}"='${gh_ref}' "${3}"='${ABL_GH_URL_API}/tarball/${gh_ref}' "${4}"='${gh_channel}'
	: "${gh_channel}" # silence shellcheck warning

	:
}

# 1 - new version
# 2 - path to file
update_version()
{
	${SED_CMD} -i "/^\s*#\s*ABL_VERSION=/{s/.*/# ABL_VERSION=${1}/;:1 n;b1;}" "${2}"
}

# will be executed upon update from the old version of the script, before new version is installed
abl_post_update_1()
{
	# fix incorrect rc.d symlink from older versions
	[ -f /etc/rc.d/K4adblock-lean ] && mv /etc/rc.d/K4adblock-lean /etc/rc.d/K${START}adblock-lean

	# @temp_workaround - remove a few months from now
	# when upgrading from older versions, fetch and install latest release
	if [ -z "${POST_UPDATE_1_DONE}" ] && [ -f "${ABL_DIR}/adblock-lean.latest" ]
	then
		if rc_enabled
		then
			# use installed script to clean dnsmasq dir
			(
				unset -f clean_dnsmasq_dir restart_dnsmasq
				unset action ABL_CMD
				. "${ABL_SERVICE_PATH}"
				check_util clean_dnsmasq_dir && clean_dnsmasq_dir &&
				check_util restart_dnsmasq && restart_dnsmasq
			)
		fi
		POST_UPDATE_1_DONE=1
		update -f -v latest || exit 1
		cp "${ABL_SERVICE_PATH}" "${ABL_DIR}/adblock-lean.latest"
	fi
	:
}

# assigns path to extracted distribution directory to $1
# (optional) 1 - '-n' to quiet
# 1 - var name for output
# 2 - tarball url
# 3 - github ref
fetch_abl_dist()
{
	if [ "${1}" = '-n' ]
	then
		shift
	else
		reg_action -blue "Downloading adblock-lean, version '${3}'." || return 1
	fi

	local fetch_tarball_url="${2}"
	local fetch_dir fetch_rv tarball="${ABL_UPD_DIR}/remote_abl.tar.gz"

	rm -rf "${UCL_ERR_FILE}" "${ABL_UPD_DIR}/lynxthecat-adblock-lean-"*
	uclient-fetch "${fetch_tarball_url}" -O "${tarball}" 2> "${UCL_ERR_FILE}" &&
	grep -q "Download completed" "${UCL_ERR_FILE}" &&
	tar -C "${ABL_UPD_DIR}" -xzf "${tarball}" &&
	fetch_dir="$(find "${ABL_UPD_DIR}/" -type d -name "lynxthecat-adblock-lean-*")"
	fetch_rv=${?}

	[ "${fetch_rv}" != 0 ] && [ -s "${UCL_ERR_FILE}" ] && ! grep -q "Download completed" "${UCL_ERR_FILE}" &&
		reg_failure "uclient-fetch errors: '$(cat "${UCL_ERR_FILE}")'."
	rm -f "${UCL_ERR_FILE}"
	eval "${1}"='${fetch_dir}'
	: "${fetch_dir}" # silence shellcheck warning
	return ${fetch_rv}
}

# 1 - path to distribution dir
# 2 - version string to write to files
install_abl_files()
{
	local file preinst_path new_files curr_files
	local dist_dir="${1}" version="${2}"

	# read new files list
	read -r new_files < "${dist_dir}/inst_files" ||
	{
		reg_failure "Failed to read file '${dist_dir}/inst_files'."
		return 1
	}

	# compile current files list
	curr_files="${ABL_SERVICE_PATH}"
	for file in ${ABL_LIB_FILES} ${ABL_EXTRA_FILES}
	do
		add2list curr_files "${file}" " "
	done

	# delete obsolete files
	for file in ${curr_files}
	do
		if [ -f "${file}" ] && ! is_included "${file}" "${new_files}" " "
		then
			log_msg "Deleting obsolete file ${file}."
			rm -f "${file}"
		fi
	done

	for file in ${new_files}
	do
		case "${file##*/}" in
			adblock-lean) preinst_path="${dist_dir}/adblock-lean" ;;
			*) preinst_path="${dist_dir}/${file}"
		esac

		# set new ABL_VERSION
		update_version "${version}" "${preinst_path}"

		if [ -f "${file}" ] && check_util md5sum && [ "$(get_md5 "${preinst_path}")" = "$(get_md5 "${file}")" ]
		then
			log_msg "File '${file}' did not change - not updating."
		else
			log_msg "Copying file '${file##*/}'."
			{ [ -d "${file%/*}" ] || try_mkdir -p "${file%/*}"; } &&
				cp "${preinst_path}" "${file}" ||
			{
				reg_failure "Failed to copy file '${file##*/}'."
				return 1
			}
		fi
	done

	chmod +x "${ABL_SERVICE_PATH}"
	:
}

# shellcheck disable=SC2120
# get config format from config or main script file contents
# input via STDIN or ${1}
get_config_format()
{
	local conf_form_sed_expr='/^[ \t]*(CONFIG_FORMAT|#[ \t]*config_format)=v/{s/.*=v//;p;:1 n;b1;}'
	if [ -n "${1}" ]
	then
		$SED_CMD -En "${conf_form_sed_expr}" "${1}"
	else
		$SED_CMD -En "${conf_form_sed_expr}"
	fi
}


### MAIN COMMAND FUNCTIONS

version()
{
	local version='' upd_channel=''
	get_abl_version "${ABL_SERVICE_PATH}" version upd_channel
	print_msg "adblock-lean version: '${version}', update channel: '${upd_channel}'."
}

gen_config()
{
	init_command gen_config &&
	do_gen_config
}

setup()
{
	# set luci feedback vars to failed, unset later upon success
	luci_pkgs_install_failed=1 luci_cron_job_creation_failed=1

	init_command setup &&
	do_setup
}

print_log()
{
	[ ! -s "${ABL_SESSION_LOG_FILE}" ] && { log_msg -err "Session log file '${ABL_SESSION_LOG_FILE}' doesn't exist or is empty."; exit 1; }
	echo "Most recent session log:"
	cat "${ABL_SESSION_LOG_FILE}"
	:
}

upd_cron_job()
{
	local me="upd_cron_job" curr_cron cron_line

	log_msg -purple "" "Updating cron job for adblock-lean."

	init_command upd_cron_job || return 1

	case "${cron_schedule}" in
		'') reg_failure "${me}: the \$cron_schedule variable is unset."; return 1 ;;
		disable)
			log_msg -yellow "cron_schedule is set to 'disable' in config."
			rm_cron_job
			return 0
	esac

	enable_cron_service || return 1
	curr_cron="$(get_curr_crontab)"
	case ${?} in
		0) print_msg "${green}Cron job for adblock-lean with schedule '${cron_schedule}' aldready exists.${n_c}"; return 0 ;;
		1) return 1 ;;
		2) curr_cron="$(printf %s "${curr_cron}" | $SED_CMD "s~^.*${ABL_CRON_CMD}.*\$~~")" ;; # remove cron job with a different schedule
		3) ;; # no adblock-lean cron job exists
	esac

	cron_line="${cron_schedule} RANDOM_DELAY=1 ${ABL_CRON_CMD} 1>/dev/null"

	#### Create new cron job
	log_msg "Creating cron job with schedule '${blue}${cron_schedule}${n_c}'."
	printf '%s\n' "${curr_cron}${_NL_}${cron_line}" | $SED_CMD '/^$/d' | crontab -u root - ||
		{ reg_failure "Failed to update crontab."; return 1; }
	:
}

select_dnsmasq_instance() {
	init_command select_dnsmasq_instance &&
	do_select_dnsmasq_instance "${@}"
}

# 1 - (optional) '-noexit' to return to the calling function
gen_stats()
{
	source_libs &&
	reg_action -blue "Generating dnsmasq stats." || exit 1
	local dnsmasq_pid
	dnsmasq_pid="$(pidof /usr/sbin/dnsmasq)" || { reg_failure "Failed to detect dnsmasq PID or dnsmasq is not running."; exit 1; }
	kill -USR1 "${dnsmasq_pid}"
	print_msg "dnsmasq stats available for reading using 'logread'."
	[ "${1}" != '-noexit' ] && exit 0
	:
}

boot()
{
	init_command boot || exit 1
	log_msg -purple "Sleeping for ${boot_start_delay_s} seconds."
	sleep "${boot_start_delay_s}"
	start "$@"
}

start()
{
	local version
	get_abl_version "${ABL_SERVICE_PATH}" version
	reg_action -purple "Starting adblock-lean, version ${version}."
	init_command start || exit 1

	if [ "${RANDOM_DELAY}" = "1" ]
	then
		random_delay_mins=$(($(hexdump -n 1 -e '"%u"' </dev/urandom)%60))
		reg_action -purple "Delaying adblock-lean by: ${random_delay_mins} minutes (thundering herd prevention)." || exit 1
		sleep "${random_delay_mins}m"
	fi

	try_export_existing_blocklist
	[ ${?} = 1 ] && exit 1

	if ! generate_and_process_blocklist_file
	then
		reg_failure "Failed to generate new blocklist."
		restore_saved_blocklist || stop 1
		check_active_blocklist || { reg_failure "Active blocklist check failed with previous blocklist file."; stop 1; }
		log_msg -green "Previous blocklist restored and dnsmasq check passed."
		exit 1
	fi

	check_for_updates
	exit 0
}

# 1 - (optional) exit code
# 1/2 - (optional) '-noexit' to return to the calling function
stop()
{
	local stop_rc=0 noexit=
	for _arg in "$@"
	do
		case "${_arg}" in
			"-noexit") noexit=1 ;;
			*[!0-9]*|'') ;;
			*) stop_rc="${_arg}"
		esac
	done
	msg="${msg% }"

	init_command stop || exit 1

	# get DNSMASQ_CONF_D without calling load_config()
	[ -f "${ABL_CONFIG_FILE}" ] &&
	DNSMASQ_CONF_D="$($SED_CMD -n '/^\s*DNSMASQ_CONF_D=/{s/^\s*DNSMASQ_CONF_D=//;s/\s*#.*//;s/"//g;p;q;}' "${ABL_CONFIG_FILE}")" &&
	[ -n "${DNSMASQ_CONF_D}" ] ||
	{
		reg_failure "Failed to get DNSMASQ_CONF_D from config. Can not delete the blocklist from dnsmasq config directory."
		exit 1
	}

	log_msg "Removing any adblock-lean blocklist files in dnsmasq config directories."
	clean_dnsmasq_dir || exit 1
	restart_dnsmasq -nostop || stop_rc=1
	log_msg -purple "" "Stopped adblock-lean."
	[ -n "$noexit" ] && return "${stop_rc}"
	exit "${stop_rc}"
}

restart()
{
	init_command restart || exit 1
	stop -noexit || exit 1
	start
}

reload()
{
	restart
}

# return codes:
# 0 - adblock-lean blocklist is loaded
# 1 - error
# 2 - adblock-lean is performing an action
# 3 - adblock-lean is paused
# 4 - adblock-lean is stopped
status()
{
	local run_state version active_entries_cnt=0 dnsmasq_status=''
	init_command status || exit 1
	check_lock
	case ${?} in
		1) exit 1 ;;
		2)
			report_pid_action
			exit 2
	esac
	get_abl_run_state
	run_state=${?}
	get_abl_version "${ABL_SERVICE_PATH}" version
	log_msg -purple "" "adblock-lean (${version}) status:"
	case ${run_state} in
		0) ;;
		3) log_msg -yellow "" "adblock-lean is paused." ;;
		4) log_msg -yellow "" "adblock-lean is stopped."
	esac

	rc_enabled
	case ${?} in
		0) log_msg -green "" "adblock-lean service is enabled." ;;
		1) log_msg -yellow "" "adblock-lean service is disabled."
	esac

	if [ "${run_state}" = 0 ]
	then
		check_active_blocklist
		dnsmasq_status=${?}
		luci_dnsmasq_status=${dnsmasq_status}
		if [ ${dnsmasq_status} = 0 ]
		then
			active_entries_cnt="$(get_active_entries_cnt)" && [ "${active_entries_cnt}" != 0 ] ||
				{ reg_failure "No entries found in the blocklist file."; run_state=1; }
			luci_good_line_count=${active_entries_cnt}
			log_msg "The dnsmasq check passed and the presently installed blocklist has entries count: $(int2human "${active_entries_cnt}")."
			log_msg -green "adblock-lean is active."
			gen_stats -noexit
		else
			reg_failure "The dnsmasq check failed with existing blocklist file."
			run_state=1
			log_msg "Consider a full reset by running: 'service adblock-lean restart'."
		fi
	fi

	check_for_updates
	luci_update_status=${?}

	exit ${run_state}
}

pause()
{
	init_command pause || exit 1
	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -err "adblock-lean is already paused."; exit 1 ;;
		4) log_msg -err "adblock-lean is currently stopped."; exit 1;
	esac
	reg_action -purple "Pausing adblock-lean." || exit 1
	try_export_existing_blocklist || exit 1
	restart_dnsmasq || exit 1
	log_msg -purple "adblock-lean is now paused."
	exit 0
}

resume()
{
	init_command resume || exit 1
	get_abl_run_state
	case ${?} in
		0) log_msg -err "adblock-lean is already running."; exit 1 ;;
		3) ;;
		4) log_msg -err "adblock-lean is currently stopped, not paused. Can not resume."; exit 1;
	esac

	reg_action -purple "Resuming adblock-lean." || exit 1
	restore_saved_blocklist || stop 1
	log_msg -purple "adblock-lean is now resumed."
	exit 0
}

# optional: '-s <path>' to simulate update (intended for testing: service adblock-lean update -s <path_to_new_ver> -v <version>)
# optional: -v [latest|snapshot|v<version>|tag=<github_tag>|commit=<commit_hash>]
# optional: '-f' to skip calling stop()
update()
{
	upd_failed()
	{
		local fail_msg="${1}"
		[ -s "${UCL_ERR_FILE}" ] && fail_msg="${fail_msg} uclient-fetch errors: '$(cat "${UCL_ERR_FILE}")'"
		[ -n "${fail_msg}" ] && reg_failure "${fail_msg}"
		reg_failure "Failed to update adblock-lean."
		rm -rf "${ABL_UPD_DIR}" "${ABL_PID_DIR}" "${UCL_ERR_FILE}"
	}

	failsafe_log()
	{
		printf '%s\n' "${1}" > "${MSGS_DEST:-/dev/tty}"
		logger -t adblock-lean "${1}"
	}

	unexp_arg()
	{
		upd_failed "update: unexpected argument '${1}'."
	}

	init_command update || { upd_failed; return 1; }

	local file version='' force_update='' dist_dir='' ref='' tarball_url='' upd_channel='' prev_config_format upd_config_format

	while getopts ":s:v:f" opt; do
		case ${opt} in
			s) SIM_PATH=${OPTARG} ;;
			v) version=${OPTARG} ;;
			f) force_update=1 ;;
			*) unexp_arg "-${OPTARG}"; return 1
		esac
	done
	shift $((OPTIND-1))
	[ -z "${*}" ] || { unexp_arg "${*}"; return 1; }

	[ -z "${force_update}" ] && stop -noexit

	rm -rf "${ABL_UPD_DIR}"
	try_mkdir -p "${ABL_UPD_DIR}" || { upd_failed; return 1; }

	if [ -n "${SIM_PATH}" ]
	then
		print_msg "${yellow}Running in simulation mode.${n_c}"
		[ -d "${SIM_PATH}" ] || { upd_failed "Directory '${SIM_PATH}' does not exist."; return 1; }
		[ -n "${version}" ] || { upd_failed "Specify new version."; return 1; }
		upd_channel=release ref="${version}"
		dist_dir="${ABL_UPD_DIR}/simulation"
		try_mkdir -p "${dist_dir}" || { upd_failed; return 1; }
		cp -rT "${SIM_PATH}" "${dist_dir}"
	else
		: "${version:=latest}"
		get_gh_ref_data "${version}" ref tarball_url upd_channel &&
		fetch_abl_dist dist_dir "${tarball_url}" "${ref}" || { upd_failed; return 1; }
	fi

	prev_config_format="${CONFIG_FORMAT#v}"
	upd_config_format="$(get_config_format < "${dist_dir}/adblock-lean")"

	unset action ABL_CMD # prevents infinite loop

	(
		# shellcheck disable=SC2030
		UPD_SOURCED=1

		# unset vars and functions from current version to have a clean slate with the new version
		unset ABL_LIB_FILES ABL_EXTRA_FILES LIBS_SOURCED CONFIG_FORMAT libs_missing
		unset -f abl_post_update_1 abl_post_update_2 load_config update source_libs
		export pid_file="${PID_FILE}" # for compatibility with older versions

		curr_dist_dir="${dist_dir}"

		# shellcheck source=/dev/null
		. "${dist_dir}/adblock-lean" || { failsafe_log "Error: Failed to source the downloaded script."; exit 1; }

		# call abl_post_update_1() in new version
		check_util abl_post_update_1 && abl_post_update_1

		printf '%s\n' "${ABL_SERVICE_PATH} ${ABL_LIB_FILES} ${ABL_EXTRA_FILES}" > "${curr_dist_dir}/inst_files"

		if [ -n "${upd_config_format}" ] && [ -n "${prev_config_format}" ] && [ "${upd_config_format}" != "${prev_config_format}" ]
		then
			failsafe_log "NOTE: config format has changed from v${prev_config_format} to v${upd_config_format}."
			# load config and call abl_post_update_2() in new version
			if { ! check_util source_libs || source_libs "${curr_dist_dir}${ABL_LIB_DIR}" "${curr_dist_dir}"; } &&
					check_util load_config
			then
				load_config
				check_util abl_post_update_2 && abl_post_update_2
			else
				failsafe_log "Please run 'service adblock-lean start' to initialize the new config."
			fi
		fi
		:
	) 1>/dev/null || { upd_failed "Failed to source the new version of adblock-lean. Update is cancelled."; return 1; }

	install_abl_files "${dist_dir}" "${upd_channel}_${ref}" || { upd_failed; return 1; }
	rm -rf "${ABL_UPD_DIR}" "${ABL_PID_DIR}" "${UCL_ERR_FILE}"

	# shellcheck disable=SC2031
	[ -n "${UPD_SOURCED}" ] && return 0

	enable || return 1
	log_msg -green "adblock-lean has been updated to version '${version}'."

	if [ -n "${DO_DIALOGS}" ]
	then
		print_msg "" "Start adblock-lean now? (y|n)"
		pick_opt "y|n"
		if [ "$REPLY" = y ]
		then
			# shellcheck source=/dev/null
			. "${ABL_SERVICE_PATH}" || return 1
			start
		fi
	fi
	:
}

uninstall()
{
	log_msg -purple "" "Uninstalling adblock-lean."
	stop -noexit
	if rc_enabled
		then
		log_msg -purple "" "Disabling adblock-lean."
		rc_disable && ! rc_enabled ||
			{ reg_failure "Failed to disable adblock-lean. Disable manually and then run this command again."; exit 1; }
	fi

	rm_cron_job

	if [ -n "${DO_DIALOGS}" ]
	then
		print_msg "" "Delete the config directory ${ABL_CONFIG_DIR}?"
		pick_opt "y|n"
	else
		REPLY="${luci_uninstall_rm_config:-n}"
	fi

	if [ "${REPLY}" = y ]
	then
		log_msg -purple "" "Deleting the config directory."
		rm -rf "${ABL_CONFIG_DIR}" || reg_failure "Failed to delete the config directory '${ABL_CONFIG_DIR}'."
	fi

	local i="-1" addnmount_deleted=1
	while [ ${i} -lt 128 ]
	do
		i=$((i+1))
		uci -q get dhcp.@dnsmasq[${i}] >/dev/null || break
		case "$(uci -q get dhcp.@dnsmasq[${i}].addnmount)" in */bin/busybox*) ;; *) continue; esac
		addnmount_deleted=
		log_msg -purple "" "Deleting the custom addnmount entry from /etc/config/dhcp."
		if uci -q del_list dhcp.@dnsmasq[${i}].addnmount='/bin/busybox' && uci commit
		then
			case "$(uci -q get dhcp.@dnsmasq[${i}].addnmount)" in */bin/busybox*) continue; esac
			addnmount_deleted=1
			log_msg "Note: the adblock-lean developers are not aware of any other software that requires the specific addnmount entry created by adblock-lean." \
				"Should the addnmount entry be required for any reason then you will need to manually re-add it."
		fi
		break
	done
	[ -z "${addnmount_deleted}" ] &&
		reg_failure "Failed to delete the custom addnmount entry from /etc/config/dhcp. Please delete manually."

	log_msg -purple "" "Deleting the scripts."
	rm -f "${ABL_SERVICE_PATH}"
	rm -rf "${ABL_LIB_DIR}"

	log_msg -purple "" "Uninstall complete."
	exit 0
}

enable()
{
	if rc_enabled
	then
		log_msg -green "The adblock-lean service is already enabled."
		return 0
	fi
	log_msg -purple "" "Enabling the adblock-lean service."
	rc_enable && rc_enabled ||
		{ reg_failure "Failed to enable the adblock-lean service"; return 4; }
	source_libs && load_config || return 3
	[ -n "${cron_schedule}" ] && { upd_cron_job || return 6; }
	:
}

disable()
{
	local rv=0
	if rc_enabled
	then
		log_msg -purple "Disabling adblock-lean."
		rm_cron_job
		rc_disable && ! rc_enabled ||
			{ reg_failure "Failed to disable the adblock-lean service"; local rv=1; }
		stop -noexit
	else
		log_msg "The adblock-lean service is already disabled."
	fi
	return "$rv"
}


set_ansi

# test process substitution support
printf '%s\n%s\n' "#!/bin/sh" "printf %s >(:)" > /tmp/abl-test
if ! /bin/sh /tmp/abl-test 1>/dev/null 2>/dev/null
then
	rm -f /tmp/abl-test
	reg_failure "This shell does not support process substitution. To use adblock-lean, please update OpenWrt to 22.03 or later version."
	exit 1
fi
rm -f /tmp/abl-test

detect_utils

# register 1st arg as $ABL_CMD when called by 'sh /etc/init.d/adblock-lean'
if [ "${0}" = "${ABL_SERVICE_PATH}" ]
then
	ABL_CMD="${1}"
	shift
fi

# shellcheck source=/dev/null
# this is needed when running via 'sh /etc/init.d/adblock-lean'
check_util config_load 1>/dev/null || . /lib/functions.sh || { reg_failure "Failed to source /lib/functions.sh"; exit 1; }

# detect when sourced from update() in older versions
check_util failsafe_log 1>/dev/null && UPD_SOURCED=1

case "${ABL_CMD}" in
	enable|disable|uninstall|update|setup) ${ABL_CMD} "${@}"; exit ${?} ;;
esac

:
