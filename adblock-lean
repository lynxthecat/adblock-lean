#!/bin/sh /etc/rc.common
# shellcheck disable=SC3043,SC2018,SC3020,SC1090,SC3045,SC2155,SC2015,SC3057,SC3044,SC2016,SC3003,SC3060

# adblock-lean - powerful and ultra efficient adblocking with dnsmasq on OpenWrt
# Project homepage: https://github.com/lynxthecat/adblock-lean
ABL_VERSION=dev
ABL_UPD_CHANNEL=release

START=99
STOP=04

# Authors: @Lynx and @Wizballs (OpenWrt forum)
# Contributors: @antonk; @dave14305 (OpenWrt forum)

# global exit codes:
# 0 - Success
# 1 - Error
# 254 - Failed to acquire lock

# special variables for luci have the prefix 'luci_'

# expects that the RPC script for luci UI is named specifically 'luci.adblock-lean'

# get return value of built-in actions
action_rv="${?}"

LC_ALL=C
DEFAULT_IFS='	 
'
_NL_='
'
IFS="${DEFAULT_IFS}"

CONFIG_FORMAT=v8

if [ -z "${MSGS_DEST}" ]
then
	if [ -t 0 ]
	then
		export MSGS_DEST=/dev/tty
	else
		export MSGS_DEST=/dev/null
	fi
fi

ABL_DIR=/var/run/adblock-lean
ABL_LIB_DIR=/usr/lib/adblock-lean
ABL_CONFIG_DIR=/etc/adblock-lean
ABL_PID_DIR=/tmp/adblock-lean
ABL_UPD_DIR="/var/run/adblock-lean-update"
ABL_CONF_STAGING_DIR="/tmp/abl-conf-staging"

ABL_SERVICE_PATH=/etc/init.d/adblock-lean

ABL_FILE_TYPES="GEN LIB EXTRA"

ABL_GEN_FILES="${ABL_SERVICE_PATH}"
ABL_LIB_FILES="${ABL_LIB_DIR}/abl-lib.sh
	${ABL_LIB_DIR}/abl-process.sh"
ABL_EXTRA_FILES="" # may be useful in the future
ABL_EXEC_FILES="${ABL_SERVICE_PATH}"

ABL_FILES_REG_PATH=/etc/adblock-lean/abl-reg.md5

ABL_CONFIG_FILE=${ABL_CONFIG_DIR}/config

PID_FILE="${ABL_PID_DIR}/adblock-lean.pid"
ACTION_FILE="${ABL_PID_DIR}/adblock-lean.action"

ABL_UPDATE_LOG_FILE=/var/log/abl_update.log
ABL_SESSION_LOG_FILE=/var/log/abl_session.log
UCL_ERR_FILE="${ABL_DIR}/uclient-fetch_err"

ABL_CRON_CMD="/etc/init.d/adblock-lean start"

ABL_GH_URL_API=https://api.github.com/repos/lynxthecat/adblock-lean
ABL_MAIN_BRANCH=master

SCHEDULER_PID=

export PATH=/usr/sbin:/usr/bin:/sbin:/bin

EXTRA_COMMANDS="setup version status pause resume gen_stats select_dnsmasq_instance gen_config upd_cron_job print_log update uninstall"
EXTRA_HELP="
adblock-lean custom commands:
	version                  print adblock-lean version
	setup                    run automated setup for adblock-lean
	status                   check dnsmasq and entries count of existing blocklist
	pause                    pause adblock-lean
	resume                   resume adblock-lean
	gen_stats                generate dnsmasq stats for system log
	select_dnsmasq_instance  analyze dnsmasq instances and set dnsmasq conf-dir
	gen_config               generate default config based on one of the pre-defined presets
	upd_cron_job             create cron job for adblock-lean with schedule set in the config option 'cron_schedule'.
	                         if config option set to 'disable', remove existing cron job if any
	print_log                print most recent session log
	update                   update adblock-lean to the latest version
	uninstall                uninstall adblock-lean, remove all adblock-lean-related files and settings"

# silence shellcheck warnings
: "${action:=}" "${action_rv}" "${EXTRA_COMMANDS}" "${EXTRA_HELP}" "${boot_start_delay_s:=}"
: "${purple}" "${green}" "${TAB}" "${CR}" "${CR_LF}"
: "${AWK_CMD}" "${SORT_CMD}"
: "${ABL_GEN_FILES}" "${ABL_LIB_FILES}" "${ABL_EXTRA_FILES}" "${ABL_EXEC_FILES}" "${CONFIG_FORMAT}"
: "${luci_log}" "${luci_pid_action}" "${luci_errors}" "${luci_dnsmasq_status}"
: "${luci_good_line_count}" "${luci_update_status}" "${luci_pkgs_install_failed}" "${luci_cron_job_creation_failed}"


### UTILITY FUNCTIONS

# check if var names are safe to use with eval
are_var_names_safe() {
	local var_name
	for var_name in "${@}"
	do
		case "${var_name}" in *[!a-zA-Z_]*) reg_failure "Invalid var name '${var_name}'."; return 1; esac
	done
	:
}

check_func()
{
	[ "$(type "${1}" 2>/dev/null | head -n1)" = "${1} is a function" ]
}

check_util()
{
	command -v "${1}" 1>/dev/null
}

# sets global variables for colors, tab delimiter and cr_lf
set_ansi()
{
	local IFS=" "
	# shellcheck disable=SC2046
	set -- $(printf '\033[0;31m \033[0;32m \033[1;34m \033[1;33m \033[0;35m \033[0m \35 \t \r')
	red="${1}" green="${2}" blue="${3}" yellow="${4}" purple="${5}" n_c="${6}" _DELIM_="${7}" TAB="${8}" CR="${9}" CR_LF="${9}${_NL_}"
}

# checks if string $1 is included in newline-separated list $2
# if $3 is specified, uses the value as list delimiter
# result via return status
is_included() {
	local delim="${3:-"${_NL_}"}"
	case "$2" in
		"$1"|"$1${delim}"*|*"${delim}$1"|*"${delim}$1${delim}"*)
			return 0 ;;
		*)
			return 1
	esac
}

# adds a string to a newline-separated list if it's not included yet
# 1 - name of var which contains the list
# 2 - new value
# 3 - (optional) list delimiter (instead of newline)
# returns 1 if bad var name, 0 otherwise
add2list() {
	case "${1}" in *[!A-Za-z0-9_]*)
		return 1
	esac

	local curr_list delim="${3:-"${_NL_}"}" fs=
	eval "curr_list=\"\${${1}}\""
	is_included "${2}" "${curr_list}" "${delim}" && return 0
	case "${curr_list}" in
		'') fs='' ;;
		*) fs="${delim}" ;;
	esac
	eval "${1}=\"\${${1}}${fs}${2}\""
	:
}

# reads first line from file into variables
# Args:
# -v <out_var_name>
# -f <file_path>
# Optional: '-a <attempts_num>'
# Optional: '-d' to delete the file after reading
# Optional: '-q' to quiet error message
# Optional: '-n X' to limit number of bytes read
# Optional: '-D <"[file_desc]">'
# Optional: '-V <"[default_val]">'
read_str_from_file()
{
	local me=read_str_from_file rs_del_file='' rs_quiet='' rs_num_bytes='' rs_outvars='' rs_file='' \
		rs_file_desc='' rs_file_desc_pr='' rs_def_val='' rs_read_failed='' rs_attempts=1 rs_attempt rs_var
	while getopts ":dqn:v:f:a:D:V:" opt
	do
		case "${opt}" in
			d) rs_del_file=1 ;;
			q) rs_quiet=1 ;;
			n) rs_num_bytes=-n${OPTARG} ;;
			v) rs_outvars=${OPTARG} ;;
			f) rs_file=${OPTARG} ;;
			a) rs_attempts=${OPTARG} ;;
			D) rs_file_desc=${OPTARG} ;;
			V) rs_def_val=${OPTARG} ;;
			*) reg_failure "${me}: unexpected option '${opt}'."; return 1;
		esac
	done

	[ -n "${rs_outvars}" ] && [ -n "${rs_file}" ] || { reg_failure "${me}: missing args"; return 1; }

	rs_attempt=0
	while :
	do
		[ -f "${rs_file}" ] && read -r ${rs_num_bytes?} ${rs_outvars?} < "${rs_file}" &&
		{
			for rs_var in ${rs_outvars}
			do
				case "${rs_var}" in _) continue; esac
				eval "[ -n \"\${${rs_var}}\" ]" && break 2
			done
		}
		rs_attempt=$((rs_attempt+1))
		[ "${rs_attempt}" -le "${rs_attempts}" ] || { rs_read_failed=1; break; }
		sleep 1
	done

	[ -n "${rs_del_file}" ] && rm -f "${rs_file}"
	[ -z "${rs_read_failed}" ] && return 0

	[ -n "${rs_file_desc}" ] && rs_file_desc_pr="${rs_file_desc} "
	[ -n "${rs_quiet}" ] || reg_failure "Failed to read ${rs_file_desc_pr}file '${rs_file}'."
	[ -n "${rs_def_val}" ] &&
	{
		for rs_var in ${rs_outvars}
		do
			case "${rs_var}" in _) continue; esac
			eval "${rs_var}=\"${rs_def_val}\""
		done
	}
	return 1
}

get_md5()
{
	md5sum "${1}" | cut -d' ' -f1
}

# 0 - (optional) '-p'
# 1 - path
try_mkdir()
{
	local p=
	[ "${1}" = '-p' ] && { p='-p'; shift; }
	[ -d "${1}" ] && return 0
	mkdir ${p} "${1}" || { reg_failure "Failed to create directory '${1}'."; return 1; }
	:
}

# asks the user to pick an option
# 1 - input in the format 'a|b|c'
# output via $REPLY
pick_opt()
{
	update_action_file "Waiting for user input in console" || return 1
	while :
	do
		printf %s "$1: " > "${MSGS_DEST}"
		read -r REPLY
		case "$REPLY" in *[!A-Za-z0-9_]*) printf '\n%s\n\n' "Please enter $1" > "${MSGS_DEST}"; continue; esac
		eval "case \"$REPLY\" in 
				$1) return 0 ;;
				*) printf '\n%s\n\n' \"Please enter $1\" > \"${MSGS_DEST}\"
			esac"
	done
}


### HELPER FUNCTIONS

# Get version and update channel of adblock-lean file
# Assigns vars $2 = version, $3 = update channel
# 1 - path to adblock-lean service file
# Return codes:
# 1 - error
# 2 - no version found
# 3 - new version format
# 4 - old version format
get_abl_version()
{
	get_ver_str()
	{
		local key_ptrn='' migr_ptrn=''
		case "${1}" in
			version)
				key_ptrn="\\s*ABL_VERSION"
				[ "${3}" = '-o' ] && migr_ptrn='s/^[^_]*_//;' ;;
			upd_channel)
				key_ptrn="\\s*ABL_UPD_CHANNEL"
				[ "${3}" = '-o' ] && { key_ptrn="\\s*ABL_VERSION" migr_ptrn='s/_.*//;'; }
		esac
		[ "${3}" = '-o' ] && key_ptrn="\\s*#${key_ptrn}"

		${SED_CMD} -n "/^${key_ptrn}=/{s/^${key_ptrn}=//;s/#.*$//;s/\"//g;${migr_ptrn}p;:1 n;b1;}" "${2}"
	}

	local gv_ver='' gv_upd_ch='' gv_rv=''
	if [ -n "${2}${3}" ]
	then
		are_var_names_safe "${2}" "${3}" || return 1
		eval "${2}"='' "${3}"=''
	fi
	# version format in v0.7.2 and later
	if grep -q '^\s*ABL_UPD_CHANNEL=' "${1}" &&
		gv_upd_ch="$(get_ver_str upd_channel "${1}")" &&
		gv_ver="$(get_ver_str version "${1}")" &&
		[ -n "${gv_upd_ch}" ] && [ -n "${gv_ver}" ]
	then
		gv_rv=3
	# version format in v0.6.0 - v0.7.1
	elif grep -q '^\s*#\s*ABL_VERSION=' "${1}" &&	
		gv_upd_ch="$(get_ver_str upd_channel "${1}" -o)" &&
		gv_ver="$(get_ver_str version "${1}" -o)" &&
		[ -n "${gv_upd_ch}" ] && [ -n "${gv_ver}" ]
	then
		gv_rv=4
	else
		gv_rv=1
	fi
	[ -n "${2}${3}" ] && eval "${2}"='${gv_ver}' "${3}"='${gv_upd_ch}'
	return ${gv_rv}
}

rc_disable()
{
	rm -f /etc/rc.d/S${START}adblock-lean /etc/rc.d/K${STOP}adblock-lean
}

rc_enable()
{
	local err=1
		ln -sf "../init.d/adblock-lean" "/etc/rc.d/S${START}adblock-lean" && err=0
		ln -sf "../init.d/adblock-lean" "/etc/rc.d/K${STOP}adblock-lean" && err=0
	return $err
}

rc_enabled()
{
	[ -L "/etc/rc.d/S${START}adblock-lean" ] &&
	[ -L "/etc/rc.d/K${STOP}adblock-lean" ]
}

# sets $AWK_CMD, $SED_CMD, $SORT_CMD
detect_utils() {
	if type gawk &> /dev/null
	then
		AWK_CMD="gawk"
	else
		AWK_CMD="busybox awk"
	fi

	if sed --version 2>/dev/null | grep -qe '(GNU sed)'
	then
		SED_CMD="sed"
	else
		SED_CMD="busybox sed"
	fi

	if sort --version 2>/dev/null | grep -qe coreutils
	then
		SORT_CMD="sort"
	else
		SORT_CMD="busybox sort"
	fi
	:
}

# 1: (optional) '-[color]'
# prints each argument into a separate line
print_msg()
{
	local m color=
	case "${1}" in -blue|-red|-green|-purple|-yellow) eval "color=\"\${${1#-}}\""; shift; esac
	for m in "${@}"
	do
		printf '%s\n' "${color}${m}${n_c}" > "$MSGS_DEST"
	done
}

# logs each message argument separately and prints to a separate line
# optional arguments: '-noprint', '-err', '-warn', '-[color]'
log_msg()
{
	local m msgs='' msgs_prefix='' _arg err_l=info color='' noprint=''

	local IFS="${DEFAULT_IFS}"
	for _arg in "$@"
	do
		case "${_arg}" in
			"-noprint") noprint=1 ;;
			"-err") err_l=err color="${red}" msgs_prefix="Error: " ;;
			"-warn") err_l=warn color="${yellow}" msgs_prefix="Warning: " ;;
			-blue|-red|-green|-purple|-yellow) color="${_arg}" ;;
			'') msgs="${msgs}dummy${_DELIM_}" ;;
			*) msgs="${msgs}${msgs_prefix}${_arg}${_DELIM_}"; [ -n "${msgs_prefix}" ] && msgs_prefix=
		esac
	done
	msgs="${msgs%"${_DELIM_}"}"
	IFS="${_DELIM_}"

	for m in ${msgs}
	do
		IFS="${DEFAULT_IFS}"
		case "${m}" in
			dummy) printf '\n' > "${MSGS_DEST}" ;;
			*)
				[ -z "${noprint}" ] && print_msg ${color} "${m}"
				logger -t adblock-lean -p user."${err_l}" "${m}"
				write_log_file "${m}" "${err_l}"
		esac
	done
	:
}

# 1 - msg
# 2 - err level
write_log_file()
{
	[ -n "${LOG_FILE}" ] && date +"[%b %d %Y, %H:%M:%S] ${2:-info}: ${1}" >> "${LOG_FILE}" &
}

# exit with code ${1}
# if function 'abl_luci_exit' is defined, execute it before exit
cleanup_and_exit()
{
	trap - INT TERM EXIT
	if [ -n "${CLEANUP_REQ}" ]
	then
		[ "${1}" != 0 ] && print_msg "" "Cleaning up..."
		[ -n "${SCHEDULER_PID}" ] && kill -s USR1 "${SCHEDULER_PID}" 2>/dev/null
		rm -rf "${ABL_DIR}"
	fi

	if [ -n "${FAIL_STOP_REQ}" ]
	then
		ABL_NOTRAPS=1 stop "${1}" -noexit
		rm -rf "${ABL_DIR}"
	fi

	rm -rf "${ABL_CONF_STAGING_DIR}"

	[ -n "${LOCK_REQ}" ] && rm_lock
	local recent_log=
	[ -n "${LOG_FILE}" ] && [ -s "${LOG_FILE}" ] && read -rd '' recent_log < "${LOG_FILE}"
	luci_log="${recent_log}"

	# execute custom script actions
	if [ -z "${luci_sourced}" ] && [ -n "${failure_msg}" ] && [ -n "${custom_scr_sourced}" ] && check_func report_failure
	then
		[ -n "${recent_log}" ] && failure_msg="${failure_msg}${_NL_}${_NL_}Session log:${_NL_}${recent_log}"
		report_failure "${failure_msg}"
	fi
	if [ -n "${UPD_AVAIL_MSG}" ] && check_func report_update
	then
		report_update "${UPD_AVAIL_MSG}${_NL_}${UPD_DIRECTIONS}"
	fi

	[ -n "${luci_sourced}" ] && abl_luci_exit "${1}"
	exit "${1}"
}

# shellcheck disable=SC2120
# 1 - (optional) '-nostop' to not call stop on failure
restart_dnsmasq()
{
	reg_action -blue "Restarting dnsmasq." || return 1

	/etc/init.d/dnsmasq restart &> /dev/null ||
	{
		reg_failure "Failed to restart dnsmasq."
		[ "${ABL_CMD}" != stop ] && [ "${1}" != '-nostop' ] && stop 1 -noexit
		return 1
	}

	reg_action -blue "Waiting for dnsmasq initialization." || return 1
	local dnsmasq_ok=
	for i in $(seq 1 60)
	do
		nslookup localhost 127.0.0.1 &> /dev/null && { dnsmasq_ok=1; break; }
		sleep 1;
	done

	[ -n "$dnsmasq_ok" ] ||
	{
		reg_failure "dnsmasq initialization failed."
		[ "${ABL_CMD}" != stop ] && [ "${1}" != '-nostop' ] && stop 1 -noexit
		return 1
	}

	log_msg -green "Restart of dnsmasq completed."
	:
}

#
# return codes:
# 0 - success
# 1 - error
# 254 - lock file already exists
mk_lock()
{
	local me=mk_lock
	check_lock
	case ${?} in
		1) return 1 ;;
		2)
			report_curr_action -log
			log_msg -yellow "Refusing to open another instance."
			return 254
	esac

	[ -z "${PID_FILE}" ] && { reg_failure "${me}: \${PID_FILE} variable is unset."; return 1; }

	try_mkdir -p "${ABL_PID_DIR}" || return 1
	printf '%s\n' "${$}" > "${PID_FILE}" || { reg_failure "${me}: Failed to write to pid file '${PID_FILE}'."; return 1; }
	:
}

# assigns lock pid to $LOCK_PID
# return codes:
# 0 - no lock
# 1 - error
# 2 - lock file exists and belongs to another PID
# 3 - lock file belongs to current PID
check_lock()
{
	unset LOCK_PID
	[ -z "${PID_FILE}" ] && { reg_failure "\${PID_FILE} variable is unset."; return 1; }
	[ ! -f "${PID_FILE}" ] && return 0

	read_str_from_file -v "LOCK_PID _" -f "${PID_FILE}" -a 3 -D PID || return 1

	case "${LOCK_PID}" in
		"${$}") return 3 ;;
		*[!0-9]*) reg_failure "pid file '${PID_FILE}' contains unexpected string '${LOCK_PID}'."; unset LOCK_PID; return 1 ;;
		*) kill -0 "${LOCK_PID}" 2>/dev/null && return 2
	esac

	log_msg -warn "Detected stale pid file '${PID_FILE}' for PID ${LOCK_PID}. Removing."
	rm_lock || return 1
	:
}

rm_lock()
{
	rm -f "${PID_FILE}" || { reg_failure "Failed to delete the pid file '${PID_FILE}'."; return 1; }
	rm -rf "${ABL_PID_DIR}"
	LOCK_PID=
	:
}

# updates the pid file with a new action
# 1 - new action
update_action_file()
{
	local me="update_action_file"
	[ -z "${1%.}" ] && { reg_failure "${me}: action is unspecified."; return 1; }

	{
		try_mkdir -p "${ABL_PID_DIR}" &&
		printf '%s\n' "${1%.}" > "${ACTION_FILE}" || reg_failure "${me}: Failed to write to action file '${ACTION_FILE}'."
	} & # runs asynchronously
	:
}

# 1 (optional): '-log' to log current action as well
report_curr_action()
{
	[ "${MSGS_DEST}" = "/dev/null" ] && [ -z "${luci_sourced}" ] && [ "${1}" != "-log" ] && return 0
	local reported_pid report_cmd=print_msg
	[ -n "${ACTION_FILE}" ] || { reg_failure "\$ACTION_FILE var is unset."; return 1; }
	[ -f "${ACTION_FILE}" ] || return 0
	if [ -z "${LOCK_PID}" ]
	then
		check_lock
		case ${?} in
			0) return 0 ;;
			1) return 1 ;;
			2|3) ;;
		esac
	fi
	reported_pid="${LOCK_PID:-unknown}"

	read_str_from_file -v PID_ABL_CMD -f "${ACTION_FILE}" -a 2 -D action -V "unknown action"

	[ "${1}" = -log ] && report_cmd=log_msg

	${report_cmd} "adblock-lean (PID: ${reported_pid}) is performing action '${PID_ABL_CMD}'."
	luci_pid_action=${PID_ABL_CMD}
	:
}

# (optional) -nolog
# (optional) -[color]
# other args - action
reg_action()
{
	local arg msg='' nolog='' color=''
	for arg in "$@"
	do
		case "${arg}" in
			-nolog) nolog=1 ;;
			-blue|-red|-green|-purple|-yellow) color="${arg}" ;;
			*) msg="${msg}${arg} "
		esac
	done

	[ -z "${nolog}" ] && log_msg "" ${color} "${msg% }"
	if [ -n "${LOCK_REQ}" ]
	then
		update_action_file "${msg% }" || return 1
	fi
	:
}

reg_failure()
{
	log_msg -err "" "${1}"
	failure_msg="${failure_msg}${1}${_NL_}"
	luci_errors="${failure_msg}"
}

reg_success()
{
	if [ -n "${custom_scr_sourced}" ] && check_func report_success
	then
		report_success "${1}"
	fi
}

# kills any running adblock-lean instances
kill_abl_pids()
{
	local abl_pids
	check_lock
	if [ ${?} = 2 ]
	then
		kill "${LOCK_PID}" 2>/dev/null
	else
		# if PID file doesn't exist, check for running abl processes just in case
		local pgrep_ptrn="(^((sh|/bin/sh)\s+){0,1}(/etc/rc.common\s+){0,1}/etc/(rc.d/S${START}|init.d/)|luci\.)adblock-lean"
		abl_pids="$(pgrep -fa "${pgrep_ptrn}" | ${SED_CMD} -E "/\sstop$/d;s/\s+.*//;/^${$}$/d" | tr '\n' ' ')"
		[ -n "${abl_pids}" ] && kill_pids_recursive "${abl_pids}"
	fi

	# wait for adblock-lean instance to exit
	local i=0
	while [ -f "${PID_FILE}" ] && [ ${i} -lt 10 ]
	do
		check_lock
		[ ${?} != 2 ] && break
		sleep 1
		i=$((i+1))
	done

	:
}

# kills specified pid's and their offspring
# 1 - whitespace-separated starting list of pid's
# 2 - pid's to exclude
kill_pids_recursive()
{
	# recursively add child pid's of pid $2 to whitespace-separated list stored in var $1
	# 1 - var name for output
	# 2 - pid
	add_child_pids()
	{
		local pid_scan_depth pid prev_pids child_pids
		: "${pid_scan_depth:=0}"
		pid_scan_depth=$((pid_scan_depth+1))
		[ "${pid_scan_depth}" -lt "${max_pid_scan_depth}" ] || return 0

		child_pids="$(
			pgrep -faP "${2}" |
			# exclude the dnsmasq processes and service calls from results
			${SED_CMD} -E \
				'/(^[0-9]+\s+((sh|\/bin\/sh)\s+){0,1}(\/sbin\/service\s+|\/etc\/rc.common\s+\/etc\/init.d\/){0,1}(\/usr\/sbin\/|\/sbin\/service\s){0,1}dnsmasq|\/sbin\/ujail)\s/d;
				s/\s.*//'
		)" || return 0

		eval "prev_pids=\"\${${1}}\""

		local IFS="${_NL_}"
		for pid in ${child_pids}
		do
			IFS="${DEFAULT_IFS}"
			is_included "${pid}" "${prev_pids}" " " || eval "${1}=\"\${${1}}\${pid} \""
			add_child_pids "${1}" "${pid}"
		done
	}

	local initial_pids='' exclude_pids="${2}" pid max_pid_scan_depth=10 max_k_attempts=10

	# compile a list of initial pids and recursively child pids
	for pid in ${1}
	do
		case "${pid}" in *[!0-9]*) continue; esac
		is_included "${pid}" "${exclude_pids}" " " && continue

		initial_pids="${initial_pids}${pid} "
		add_child_pids initial_pids "${pid}"
	done
	[ -n "${initial_pids}" ] || return 0

	kill "${initial_pids}" 2>/dev/null
	local running_pids="${initial_pids}" k_attempt=0
	while :
	do
		k_attempt=$((k_attempt+1))
		[ ${k_attempt} -le ${max_k_attempts} ] || break

		for pid in ${running_pids}
		do
			add_child_pids running_pids "${pid}"
		done

		kill "${running_pids}" 2>/dev/null

		local alive_pids=''
		for pid in ${running_pids}
		do
			[ -d "/proc/${pid}" ] && alive_pids="${alive_pids}${pid} "
		done
		running_pids="${alive_pids}"
		[ -n "${running_pids}" ] || return 0

		sleep 1
	done
	kill -9 "${running_pids}" 2>/dev/null
	:
}

# return codes:
# 0 - running
# 1 - error
# 2 - (reserved)
# 3 - paused
# 4 - stopped
get_abl_run_state()
{
	[ -n "${DNSMASQ_CONF_D}" ] || { reg_failure "\$DNSMASQ_CONF_D is not set"; return 1; }
	local f
	for f in "${DNSMASQ_CONF_D}/.abl-blocklist.gz" "${DNSMASQ_CONF_D}/abl-blocklist"
	do
		[ -f "${f}" ] && return 0
	done

	[ -f "${ABL_DIR}/prev_blocklist.gz" ] && return 3
	return 4
}

# 1 - types: 'ALL' (doesn't print executable files) or any combination (space-separated) of 'GEN', 'LIB', 'EXTRA', 'EXEC'
print_file_list()
{
	local me=print_file_list file_type files='' IFS="${DEFAULT_IFS}" \
		file_types="${1}"

	[ -n "$1" ] || { reg_failure "${me}: missing args."; return 1; }

	if [ "${file_types}" = ALL ]
	then
		file_types="${ABL_FILE_TYPES}"
	fi

	for file_type in ${file_types}
	do
		case "${file_type}" in
			GEN|LIB|EXTRA|EXEC)
				eval "files=\"${files}\${ABL_${file_type}_FILES}${_NL_}\"" ;;
			*) reg_failure "${me}: invalid type '${file_type}'"; return 1
		esac
	done

	# remove extra newlines, leading and trailing whitespaces and tabs
	printf '%s\n' "${files}" | ${SED_CMD} "s/^\s*//;s/\s*$//;/^$/d"
	:
}

# return codes:
# 0 - OK
# 1 - general error
# 2 - missing files
# 3 - non-matching md5sums
check_libs()
{
	local reg_file file files='' file_types

	eval "file_types=\"\${ABL_FILE_TYPES}\"
		reg_file=\"\${ABL_FILES_REG_PATH}\""

	files="$(print_file_list ALL)" && [ -n "${files}" ] ||
		{ reg_failure "Failed to get file list."; return 1; }
	
	local IFS="${_NL_}"
	for file in ${reg_file}${_NL_}${files}
	do
		[ -n "$file" ] || continue
		[ -f "$file" ] || { reg_failure "Missing file: '$file'."; return 2; }
	done

	IFS="${DEFAULT_IFS}"
	md5sum -c "${reg_file}" &>/dev/null || return 3
	:
}

source_libs()
{
	[ -n "${LIBS_SOURCED}" ] && return 0

	local file libs_missing='' libs_source_failed=''
	[ -n "${UPD_SOURCED}" ] || check_libs
	case ${?} in
		0|3) ;;
		*)
			log_msg "Please run 'sh /etc/init.d/adblock-lean update -f' to fetch required files."
			return 1
	esac

	# source libs
	for file in ${ABL_LIB_FILES}
	do
		file="${file##*/}"
		[ -f "${ABL_LIB_DIR}/${file}" ] || { libs_source_failed=1 libs_missing=1; break; }
		# shellcheck source=/dev/null
		. "${ABL_LIB_DIR}/${file}" || { libs_source_failed=1; break; }
	done

	[ -n "${libs_source_failed}" ] &&
	{
		[ -n "${libs_missing}" ] && reg_failure "Missing library scripts."
		reg_failure "Failed to source library scripts."
		return 1
	}
	LIBS_SOURCED=1
	:
}

# args: 1 - (optional) schedule
# return codes:
# 0 - cron job with same schedule exists
# 1 - error
# 2 - cron job with a different schedule exists
# 3 - cron job doesn't exist
get_curr_crontab()
{
	local curr_cron
	curr_cron="$(crontab -u root -l 2>/dev/null)" || { reg_failure "get_curr_crontab: Failed to read crontab."; return 1; }
	printf '%s\n' "${curr_cron}"

	# check if adblock-lean cron job with same schedule exists
	case "${curr_cron}" in
		*"${cron_schedule}"*"${ABL_CRON_CMD}"*) return 0 ;;
		*"${ABL_CRON_CMD}"*) return 2 ;;
		*) return 3 ;;
	esac
}

rm_cron_job()
{
	local curr_cron
	crontab -u root -l 1>/dev/null 2>/dev/null || return 0
	curr_cron="$(get_curr_crontab)"
	case ${?} in
		1) return 1 ;;
		3) return 0
	esac

	log_msg -purple "" "Removing cron job for adblock-lean."
	printf '%s\n' "${curr_cron}" | ${SED_CMD} '/adblock-lean start/d;/^$/d' | crontab -u root - ||
		{ reg_failure "Failed to update crontab."; return 1; }
	:
}


### Commands init
init_command()
{
	ABL_CMD="${1}"
	local config_req='' work_dir_req='' init_action_msg=''

	# detect if sourced from external RPC script for luci, depends on abl_luci_exit() being defined
	luci_sourced=
	check_func abl_luci_exit && luci_sourced=1

	DO_DIALOGS=
	[ -z "${luci_skip_dialogs}" ] && [ "${MSGS_DEST}" = "/dev/tty" ] && DO_DIALOGS=1

	if [ -z "${ABL_NOTRAPS}" ]
	then
		if [ -n "${UPD_SOURCED}" ]
		then
			trap 'exit 1' INT TERM
		else
			trap 'cleanup_and_exit 1' INT TERM
			trap 'cleanup_and_exit ${?}' EXIT
		fi
	fi

	# set requirements
	case ${ABL_CMD} in
		help|enabled|enable|disable|print_log|'') ;;
		gen_stats) ;;
		status) libs_req=1 work_dir_req=1 config_req=1 ;;
		upd_cron_job) libs_req=1 config_req=1 ;;
		setup|gen_config) libs_req=1 LOCK_REQ=1 ;;
		boot) libs_req=1 config_req=1 LOCK_REQ=1 ;;
		pause) libs_req=1 work_dir_req=1 config_req=1 LOCK_REQ=1 ;;
		start|resume) libs_req=1 work_dir_req=1 config_req=1 CLEANUP_REQ=1 LOCK_REQ=1 ;;
		stop)
			init_action_msg="Stopping adblock-lean."
			reg_action -purple "${init_action_msg}" || exit 1

			source_libs || exit 1
			kill_abl_pids
			check_lock
			case ${?} in
				1) exit 1 ;;
				2) reg_failure "Failed to kill running adblock-lean processes."; exit 1
			esac
			CLEANUP_REQ=1 LOCK_REQ=1 ;;
		select_dnsmasq_instance)
			libs_req=1 LOCK_REQ=1
			[ "${action}" = select_dnsmasq_instance ] && config_req=1 # require config when called directly
			;;
		reload|restart) reg_action -purple "Restarting adblock-lean." || exit 1 ;;
		update) work_dir_req=1 CLEANUP_REQ=1 LOCK_REQ=1 ;;
		*) reg_failure "Invalid action '${ABL_CMD}'."; exit 1
	esac

	# source library scripts
	if [ -n "${libs_req}" ]
	then
		source_libs || exit 1
	fi

	# report installed utils
	if [ "${ABL_CMD}" = start ]
	then
		detect_pkg_manager
		report_utils
	fi

	# register lock status at init
	check_lock
	local init_lock_status=${?}

	# make lock if needed
	if [ -n "${LOCK_REQ}" ]
	then
		mk_lock || { local rv=${?}; unset LOCK_REQ CLEANUP_REQ; exit ${rv}; }
		update_action_file "${ABL_CMD}"
	fi

	# enable writing session log if we have the lock
	LOG_FILE=
	case ${init_lock_status} in 0|3)
		LOG_FILE="${ABL_SESSION_LOG_FILE}"
		[ "${ABL_CMD}" = update ] && LOG_FILE="${ABL_UPDATE_LOG_FILE}"
	esac

	# if creating new session, rotate the old session log file
	[ "${init_lock_status}" = 0 ] && [ -n "${LOG_FILE}" ] && [ -f "${LOG_FILE}" ] && mv "${LOG_FILE}" "${LOG_FILE}.0"

	[ -n "${init_action_msg}" ] && write_log_file "${init_action_msg}" "info"

	[ -n "${work_dir_req}" ] && { try_mkdir -p "${ABL_DIR}" || exit 1; }

	if [ -n "${config_req}" ] && [ -z "${CONFIG_LOADED}" ]
	then
		load_config || { reg_failure "Failed to load config."; exit 1; }
		CONFIG_LOADED=1
	fi

	# check dnsmasq, source custom script
	case ${ABL_CMD} in
		start|pause|resume)
			check_dnsmasq_instance "${DNSMASQ_INSTANCE}" || exit 1
			if [ -n "${custom_script}" ]
			then
				custom_scr_sourced=
				# shellcheck source=/dev/null
				[ -f "${custom_script}" ] && . "${custom_script}" && custom_scr_sourced=1 ||
					reg_failure "Custom script '${custom_script}' doesn't exist or it returned an error."
			fi
	esac

	:
}

# Get GitHub ref and tarball url for specified component, update channel, branch and version
# 1 - update channel: release|snapshot|branch=<github_branch>|commit=<commit_hash>
# 2 - version (optional): [version|commit_hash]
# Output via variables:
#   $3 - github ref (version/commit hash), $4 - tarball url, $5 - version type ('version' or 'commit')
get_gh_ref()
{
	set_res_vars()
	{
		# validate resulting ref
		case "${gr_ref}" in
			*[^"${_NL_}"]*"${_NL_}"*[^"${_NL_}"]*)
				reg_failure "Got multiple download URLs for version '${gr_version}'." \
					"If using commit hash, please specify the complete commit hash string."
				return 1 ;;
			''|*[!a-zA-Z0-9._-]*)
				reg_failure "Failed to get GitHub download URL for ${gr_ver_type} '${gr_version}' (update channel: '${gr_channel}')."
				return 1
		esac

		case "${gr_channel}" in
			release|latest) gr_channel=release gr_version="${gr_ref#v}" ;;
			*) gr_version="${gr_ref}"
		esac

		eval "${3}"='${gr_version}' "${4}"='${ABL_GH_URL_API}/tarball/${gr_ref}' "${5}"='${gr_ver_type}' \
			"prev_ref"='${gr_ref}' "prev_ver_type"='${gr_ver_type}' \
			"prev_upd_channel"='${gr_channel}' "prev_version"='${gr_version}'
	}

	local gr_branch gr_branches='' gr_grep_ptrn='' gr_ref='' gr_ver_type='' gr_fetch_rv=0 \
		gr_fetch_tmp_dir="${ABL_UPD_DIR}/ref_fetch" \
		prev_ref prev_ver_type prev_upd_channel prev_version \
		gr_channel="${1}" gr_version="${2}"

	[ "$gr_channel" = release ] && gr_version="${gr_version#v}"

	local gr_ucl_err_file="${gr_fetch_tmp_dir}/ucl_err"

	are_var_names_safe "${3}" "${4}" "${5}" || return 1
	eval "${3}='' ${4}='' ${5}=''"

	eval "prev_ref=\"\${prev_ref}\"
		prev_ver_type=\"\${prev_ver_type}\"
		prev_upd_channel=\"\${prev_upd_channel}\"
		prev_version=\"\${prev_version}\""

	# if commit hash is specified and it's 40-char long, use it directly without API query or cache check
	case "${gr_channel}" in
		snapshot|branch=*|commit=*) [ "${#gr_version}" = 40 ] && gr_ref="${gr_version}"
	esac

	# if previously stored data exists, use it without API query or cache check
	if [ -z "${gr_ref}" ] && [ -n "${prev_ref}" ] && [ -n "${prev_ver_type}" ] && \
		[ "${prev_upd_channel}" = "${gr_channel}" ] && [ "${gr_version}" = "${prev_version}" ]
	then
			gr_ref="${prev_ref}" gr_ver_type="${prev_ver_type}"
	elif [ -z "${gr_ref}" ]
	then
		# ref cache
		local cache_ttl cache_file cache_filename="${gr_version}_${gr_channel}" gr_cache_dir="/tmp/abl_cache"
		case "${gr_channel}" in
			commit=*) cache_ttl=2880 ;; # 48 hours
			*) cache_ttl=10 # 10 minutes
		esac

		# clean up old cache
		find "${gr_cache_dir:-?}" -maxdepth 1 -type f -mmin +"${cache_ttl}" -exec rm -f {} \; 2>/dev/null

		# check if the query is cached
		cache_file="$(find "${gr_cache_dir:-?}" -maxdepth 1 -type f -name "${cache_filename}" -print 2>/dev/null)"
		case "${cache_file}" in
			'') ;; # found nothing
			*[^"${_NL_}"]*"${_NL_}"*[^"${_NL_}"]*)
				# found multiple files - delete them
				local file IFS="${_NL_}"
				for file in ${cache_file}
				do
					[ -n "${file}" ] || continue
					rm -f "${file}"
				done
				IFS="${DEFAULT_IFS}" ;;
			*)
				# found cached query
				if [ -z "${IGNORE_CACHE}" ] && [ -f "${cache_file}" ] &&
					read -r prev_ref prev_ver_type < "${cache_file}" &&
					[ -n "${prev_ref}" ] && [ -n "${prev_ver_type}" ]
				then
					gr_ref="${prev_ref}" gr_ver_type="${prev_ver_type}"
				else
					rm -f "${cache_file:-???}"
				fi
		esac
	fi

	if [ -n "${gr_ref}" ]
	then
		set_res_vars "${@}" || return 1
		return 0
	fi

	try_mkdir -p "${gr_fetch_tmp_dir}" || return 1
	rm -f "${gr_ucl_err_file}"

	case "${gr_channel}" in
		release)
			gr_ver_type=version
			[ -n "${gr_version}" ] && gr_grep_ptrn="^v${gr_version#v}$" ;;
		snapshot)
			gr_ver_type=commit
			gr_branches="${ABL_MAIN_BRANCH}"
			[ -n "${gr_version}" ] && gr_grep_ptrn="^${gr_version}$" ;;
		branch=*)
			gr_ver_type=commit
			gr_branches="${gr_channel#*=}"
			[ -n "${gr_version}" ] && gr_grep_ptrn="^${gr_version}$" ;;
		commit=*)
			gr_ver_type=commit
			local gr_hash="${gr_channel#*=}"

			if [ "${#gr_hash}" = 40 ]
			then
				# if upd. ch. is 'commit', the upd. ch. string includes commit hash -
				#    if it's 40-char long, use it directly without API query
				gr_ref="${gr_hash}"
			else
				gr_branches="$(
					uclient-fetch "${ABL_GH_URL_API}/branches" -O-  2> "${gr_ucl_err_file}" |
						{ jsonfilter -e '@[@]["name"]'; cat 1>/dev/null; }
				)"
				[ -n "${gr_branches}" ] || {
					reg_failure "Failed to get adblock-lean branches via GH API (url: '${ABL_GH_URL_API}/branches')."
					[ -f "${gr_ucl_err_file}" ] &&
						log_msg "uclient-fetch log:${_NL_}$(cat "${gr_ucl_err_file}")"
						rm -f "${gr_ucl_err_file}"
					return 1
				}
				rm -f "${gr_ucl_err_file}"
				gr_grep_ptrn="^${gr_hash}"
			fi ;;
		*)
			reg_failure "Invalid update channel '${gr_channel}'."
			return 1
	esac

	# Get GH ref
	[ -z "${gr_ref}" ] && gr_ref="$(
		case "${gr_channel}" in
			release)
				uclient-fetch "${ABL_GH_URL_API}/releases" -O- 2> "${gr_ucl_err_file}" | {
					jsonfilter -e '@[@.prerelease=false]' |
					jsonfilter -a -e "@[@.target_commitish=\"${ABL_MAIN_BRANCH}\"].tag_name"
					cat 1>/dev/null
				} ;;
			snapshot|branch=*|commit=*)
				for gr_branch in ${gr_branches}
				do
					ref_fetch_url="${ABL_GH_URL_API}/commits?sha=${gr_branch}"
					uclient-fetch "${ref_fetch_url}" -O- 2> "${gr_ucl_err_file}" | {
						jsonfilter -e '@[@.commit]["url"]' |
						${SED_CMD} 's/.*\///' # only leave the commit hash
						cat 1>/dev/null
					}
				done
		esac |
		{
			if [ -n "${gr_grep_ptrn}" ]
			then
				grep "${gr_grep_ptrn}"
			else
				head -n1 # get latest version or commit
			fi
			cat 1>/dev/null
		}
	)"

	if [ -z "${gr_ref}" ]
	then
		gr_fetch_rv=1
		reg_failure "Failed to get GitHub download URL for ${gr_ver_type} '${gr_version}' (update channel: '${gr_channel}')."
		[ -f "${gr_ucl_err_file}" ] && log_msg "uclient-fetch output:${_NL_}$(cat "${gr_ucl_err_file}")"
	fi
	rm -rf "${gr_fetch_tmp_dir:-?}"
	[ "$gr_fetch_rv" = 0 ] || return 1

	# write query result to cache
	try_mkdir -p "${gr_cache_dir}" &&
	printf '%s\n' "${gr_ref} ${gr_ver_type}" > "${gr_cache_dir}/${cache_filename}"

	set_res_vars "${@}" || return 1
	:
}

# will be executed upon update from the old version of the script, before new version is installed
abl_post_update_1()
{
	[ -n "${POST_UPDATE_1_DONE}" ] && return 0
	POST_UPDATE_1_DONE=1

	# fix incorrect rc.d symlink from older versions
	local file
	for file in /etc/rc.d/K4adblock-lean /etc/rc.d/k99adblock-lean
	do
		[ -f "${file}" ] && mv "${file}" /etc/rc.d/K${STOP}adblock-lean
	done

	# @temp_workaround - remove a few months from now
	# when upgrading from older versions, fetch and install latest release
	if [ -f "${ABL_DIR}/adblock-lean.latest" ]
	then
		if rc_enabled
		then
			# use installed script to clean dnsmasq dir
			(
				unset -f clean_dnsmasq_dir restart_dnsmasq
				unset action ABL_CMD
				# shellcheck source=/dev/null
				. "${ABL_SERVICE_PATH}"
				check_func clean_dnsmasq_dir && clean_dnsmasq_dir &&
				check_func restart_dnsmasq && restart_dnsmasq
			)
		fi
		update -f -v release || exit 1
		cp "${ABL_SERVICE_PATH}" "${ABL_DIR}/adblock-lean.latest"
	fi

	# fixup for upgrading from v0.6.0-v0.7.1
	get_abl_version "${ABL_SERVICE_PATH}"
	local fix_ver fix_upd_channel gav_rv=${?}
	case "${gav_rv}" in
		1) exit 1 ;;
		2)
			# no version string found
			update -f -v release || exit 1
			;;
		3) ;; # new version format
		4)
			# old version format
			ABL_LIB_FILES="${ABL_LIB_FILES//$'\n'/ }"
			ABL_LIB_FILES="${ABL_LIB_FILES//$'\t'/ }"

			# version and update channel string replacement
			case "${upd_channel}" in
				''|release|latest) fix_upd_channel=release ;;
				*) fix_upd_channel="${upd_channel}"
			esac
			fix_ver="${ref:-"dev"}"

			[ -f "${dist_dir}/adblock-lean" ] &&
				busybox sed -i "
					/^\s*ABL_VERSION\s*=/{s/.*/ABL_VERSION=\"${fix_ver}\"/;}
					/^\s*ABL_UPD_CHANNEL\s*=/{s/.*/ABL_UPD_CHANNEL=\"${fix_upd_channel}\"/;}" \
						"${dist_dir}/adblock-lean"
	esac

	:
}

abl_post_update_2()
{
	:
}

# Fetches and unpacks adblock-lean distribution
# 1 - tarball url
# 2 - distribution directory
fetch_abl_dist()
{
	[ -n "${1}" ] && [ -n "${2}" ] || { reg_failure "fetch_abl_dist: missing arguments."; return 1; }

	local tarball_url_fetch="${1}" dist_dir_fetch="${2}"

	local fetch_rv extract_dir fetch_dir="${dist_dir_fetch}/fetch"
	local  tarball="${fetch_dir}/remote_abl.tar.gz" ucl_err_file="${fetch_dir}/ucl_err" \


	rm -f "${ucl_err_file}" "${tarball}"
	rm -rf "${fetch_dir}/lynxthecat-adblock-lean-"*
	try_mkdir -p "${fetch_dir}" || return 1

	uclient-fetch "${tarball_url_fetch}" -O "${tarball}" 2> "${ucl_err_file}" &&
	grep -q "Download completed" "${ucl_err_file}" &&
	tar -C "${fetch_dir}" -xzf "${tarball}" &&
	extract_dir="$(find "${fetch_dir}/" -type d -name "lynxthecat-adblock-lean-*")" &&
		[ -n "${extract_dir}" ] && [ "${extract_dir}" != "/" ]
	fetch_rv=${?}
	rm -f "${tarball}"

	[ "${fetch_rv}" != 0 ] && [ -s "${ucl_err_file}" ] &&
		log_msg "uclient-fetch output: ${_NL_}$(cat "${ucl_err_file}")."
	rm -f "${ucl_err_file}"

	[ "${fetch_rv}" = 0 ] && {
		mv "${extract_dir:-?}"/* "${dist_dir_fetch:-?}/" ||
			{ rm -rf "${extract_dir:-?}"; reg_failure "Failed to move files to dist dir."; return 1; }
	}
	rm -rf "${extract_dir:-?}" "${fetch_dir:-?}"

	return ${fetch_rv}
}

# shellcheck disable=SC2120
# get config format from config or main script file contents
# input via STDIN or ${1}
get_config_format()
{
	local conf_form_sed_expr='/^[ \t]*(CONFIG_FORMAT|#[ \t]*config_format)=v/{s/.*=v//;p;:1 n;b1;}'
	if [ -n "${1}" ]
	then
		$SED_CMD -En "${conf_form_sed_expr}" "${1}"
	else
		$SED_CMD -En "${conf_form_sed_expr}"
	fi
}


### MAIN COMMAND FUNCTIONS

version()
{
	print_msg "adblock-lean version: '${ABL_VERSION}', update channel: '${ABL_UPD_CHANNEL}'."
}

gen_config()
{
	init_command gen_config &&
	do_gen_config
}

setup()
{
	# set luci feedback vars to failed, unset later upon success
	luci_pkgs_install_failed=1 luci_cron_job_creation_failed=1

	init_command setup &&
	do_setup
}

print_log()
{
	[ ! -s "${ABL_SESSION_LOG_FILE}" ] && { log_msg -err "Session log file '${ABL_SESSION_LOG_FILE}' doesn't exist or is empty."; exit 1; }
	echo "Most recent session log:"
	cat "${ABL_SESSION_LOG_FILE}"
	:
}

upd_cron_job()
{
	local me="upd_cron_job" curr_cron cron_line

	log_msg -purple "" "Updating cron job for adblock-lean."

	init_command upd_cron_job || return 1

	case "${cron_schedule}" in
		'') reg_failure "${me}: the \$cron_schedule variable is unset."; return 1 ;;
		disable)
			log_msg -yellow "cron_schedule is set to 'disable' in config."
			rm_cron_job
			return 0
	esac

	enable_cron_service || return 1
	curr_cron="$(get_curr_crontab)"
	case ${?} in
		0) print_msg -green "Cron job for adblock-lean with schedule '${cron_schedule}' aldready exists."; return 0 ;;
		1) return 1 ;;
		2) curr_cron="$(printf %s "${curr_cron}" | $SED_CMD "s~^.*${ABL_CRON_CMD}.*\$~~")" ;; # remove cron job with a different schedule
		3) ;; # no adblock-lean cron job exists
	esac

	cron_line="${cron_schedule} RANDOM_DELAY=1 ${ABL_CRON_CMD} 1>/dev/null"

	#### Create new cron job
	print_msg -blue "Creating cron job with schedule '${blue}${cron_schedule}${n_c}'."
	printf '%s\n' "${curr_cron}${_NL_}${cron_line}" | $SED_CMD '/^$/d' | crontab -u root - ||
		{ reg_failure "Failed to update crontab."; return 1; }
	:
}

select_dnsmasq_instance() {
	init_command select_dnsmasq_instance &&
	do_select_dnsmasq_instance "${@}"
}

# 1 - (optional) '-noexit' to return to the calling function
gen_stats()
{
	source_libs &&
	reg_action -blue "Generating dnsmasq stats." || exit 1
	local dnsmasq_pid
	dnsmasq_pid="$(pidof /usr/sbin/dnsmasq)" || { reg_failure "Failed to detect dnsmasq PID or dnsmasq is not running."; exit 1; }
	kill -USR1 "${dnsmasq_pid}"
	print_msg "dnsmasq stats available for reading using 'logread'."
	[ "${1}" != '-noexit' ] && exit 0
	:
}

boot()
{
	init_command boot || exit 1
	reg_action -purple "Sleeping for ${boot_start_delay_s} seconds."
	sleep "${boot_start_delay_s}"
	start "$@"
}

start()
{
	reg_action -purple "Starting adblock-lean, version ${ABL_VERSION}."
	init_command start || exit 1

	if [ "${RANDOM_DELAY}" = "1" ]
	then
		random_delay_mins=$(($(hexdump -n 1 -e '"%u"' </dev/urandom)%60))
		reg_action -purple "Delaying adblock-lean by: ${random_delay_mins} minutes (thundering herd prevention)." || exit 1
		sleep "${random_delay_mins}m"
	fi

	try_export_existing_blocklist
	[ ${?} = 1 ] && exit 1

	FAIL_STOP_REQ=1
	if ! gen_and_process_blocklist
	then
		reg_failure "Failed to generate new blocklist."
		restore_saved_blocklist || stop 1
		check_active_blocklist || { reg_failure "Active blocklist check failed with previous blocklist file."; stop 1; }
		log_msg -green "Previous blocklist restored and dnsmasq check passed."
		FAIL_STOP_REQ=
		exit 1
	fi
	FAIL_STOP_REQ=

	check_for_updates
	exit 0
}

# 1 - (optional) exit code
# 1/2 - (optional) '-noexit' to return to the calling function
stop()
{
	local stop_rc=0 noexit=
	for _arg in "$@"
	do
		case "${_arg}" in
			"-noexit") noexit=1 ;;
			*[!0-9]*|'') ;;
			*) stop_rc="${_arg}"
		esac
	done
	msg="${msg% }"

	init_command stop || { FAIL_STOP_REQ=''; exit 1; }

	# get DNSMASQ_CONF_D without calling load_config()
	[ -f "${ABL_CONFIG_FILE}" ] &&
	DNSMASQ_CONF_D="$($SED_CMD -n '/^\s*DNSMASQ_CONF_D=/{s/^\s*DNSMASQ_CONF_D=//;s/\s*#.*//;s/"//g;p;q;}' "${ABL_CONFIG_FILE}")" &&
	[ -n "${DNSMASQ_CONF_D}" ] ||
	{
		reg_failure "Failed to get DNSMASQ_CONF_D from config. Can not delete the blocklist from dnsmasq config directory."
		stop_rc=1
	}

	log_msg "Removing any adblock-lean blocklist files in dnsmasq config directories."
	clean_dnsmasq_dir || stop_rc=1
	restart_dnsmasq -nostop || stop_rc=1
	log_msg -purple "" "Stopped adblock-lean."
	[ -n "$noexit" ] && return "${stop_rc}"
	FAIL_STOP_REQ=
	exit "${stop_rc}"
}

restart()
{
	init_command restart || exit 1
	stop -noexit || exit 1
	start
}

reload()
{
	restart
}

# return codes:
# 0 - adblock-lean blocklist is loaded
# 1 - error
# 2 - adblock-lean is performing an action
# 3 - adblock-lean is paused
# 4 - adblock-lean is stopped
status()
{
	local run_state active_entries_cnt=0 active_entries_cnt_human dnsmasq_status=''
	init_command status || exit 1
	check_lock
	case ${?} in
		1) exit 1 ;;
		2)
			report_curr_action
			exit 2
	esac
	get_abl_run_state
	run_state=${?}
	log_msg -purple "" "adblock-lean (${ABL_VERSION}) status:"
	case ${run_state} in
		0) ;;
		1) reg_failure "Failed to check adblock-lean run state." ;;
		3) log_msg -yellow "" "adblock-lean is paused." ;;
		4) log_msg -yellow "" "adblock-lean is stopped."
	esac

	rc_enabled
	case ${?} in
		0) log_msg -green "" "adblock-lean service is enabled." ;;
		1) log_msg -yellow "" "adblock-lean service is disabled."
	esac

	if [ "${run_state}" = 0 ]
	then
		check_active_blocklist
		dnsmasq_status=${?}
		luci_dnsmasq_status=${dnsmasq_status}
		if [ ${dnsmasq_status} = 0 ]
		then
			active_entries_cnt="$(get_active_entries_cnt)" && [ "${active_entries_cnt}" != 0 ] ||
				{ reg_failure "No entries found in the blocklist file."; run_state=1; }
			luci_good_line_count=${active_entries_cnt}
			int2human active_entries_cnt_human "${active_entries_cnt}"
			log_msg "The dnsmasq check passed and the presently installed blocklist has entries count: ${active_entries_cnt_human}."
			log_msg -green "" "adblock-lean is active."
			gen_stats -noexit
		else
			reg_failure "The dnsmasq check failed with existing blocklist file."
			run_state=1
			log_msg "Consider a full reset by running: 'service adblock-lean restart'."
		fi
	fi

	check_for_updates
	luci_update_status=${?}

	exit ${run_state}
}

pause()
{
	init_command pause || exit 1
	get_abl_run_state
	case ${?} in
		0) ;;
		3) log_msg -err "adblock-lean is already paused."; exit 1 ;;
		4) log_msg -err "adblock-lean is currently stopped."; exit 1;
	esac
	FAIL_STOP_REQ=1
	reg_action -purple "Pausing adblock-lean." || exit 1
	try_export_existing_blocklist || exit 1
	restart_dnsmasq || exit 1
	FAIL_STOP_REQ=
	log_msg -purple "adblock-lean is now paused."
	exit 0
}

resume()
{
	init_command resume || exit 1
	get_abl_run_state
	case ${?} in
		0) log_msg -err "adblock-lean is already running."; exit 1 ;;
		1) exit 1 ;;
		3) ;;
		4) log_msg -err "adblock-lean is currently stopped, not paused. Can not resume."; exit 1;
	esac

	reg_action -purple "Resuming adblock-lean." || exit 1
	FAIL_STOP_REQ=1
	restore_saved_blocklist || stop 1
	FAIL_STOP_REQ=
	log_msg -purple "adblock-lean is now resumed."
	exit 0
}

# optional: '-s <path>' to simulate update (intended for testing: service adblock-lean update -s <path_to_new_ver> -v <version>)
# optional: -v [release|snapshot|<version>|branch=<github_branch>|commit=<commit_hash>]
# optional: '-f' to skip calling stop()
update()
{
	# unset vars and functions from current version to have a clean slate with the new version
	clean_abl_env()
	{
		unset action ABL_CMD ABL_LIB_FILES ABL_EXTRA_FILES ABL_EXEC_FILES LIBS_SOURCED CONFIG_FORMAT
		unset -f abl_post_update_1 abl_post_update_2 load_config update source_libs check_libs install_abl_files cleanup_and_exit
	}

	upd_failed()
	{
		local fail_msg="${1}"
		[ -s "${UCL_ERR_FILE}" ] && fail_msg="${fail_msg} uclient-fetch errors: '$(cat "${UCL_ERR_FILE}")'"
		[ -n "${fail_msg}" ] && reg_failure "${fail_msg}"
		reg_failure "Failed to update adblock-lean."
		rm -rf "${ABL_UPD_DIR:-???}" "${ABL_PID_DIR:-???}" "${UCL_ERR_FILE:-???}"
	}

	unexp_arg()
	{
		upd_failed "update: unexpected argument '${1}'."
	}

	init_command update || { upd_failed; return 1; }

	local file req_ver='' ver_str_arg='' ver_type='' dist_dir='' upd_ver='' tarball_url='' \
		upd_channel='' req_upd_channel='' force_upd_channel='' force_update=''

	IGNORE_CACHE=
	while getopts ":s:v:U:W:fi" opt
	do
		case ${opt} in
			s) export sim_path="$OPTARG" ;;
			v) ver_str_arg=$OPTARG force_update=1 ;;
			U) force_upd_channel=$OPTARG force_update=1 ;;
			W) req_ver=$OPTARG force_update=1 ;;
			f) force_update=1 ;;
			i) IGNORE_CACHE=1 ;; # global var
			*) unexp_arg "$OPTARG"; return 1
		esac
	done
	shift $((OPTIND-1))
	[ -z "${*}" ] || { unexp_arg "${*}"; return 1; }

	[ -z "${force_update}" ] && stop -noexit

	# parse version string from arguments into $req_upd_channel, $req_ver
	case "${ver_str_arg}" in
		'') ;;
		release|latest)
			req_upd_channel=release req_ver='' ;;
		snapshot)
			req_upd_channel="${ver_str_arg}" req_ver='' ;;
		commit=*)
			req_upd_channel="${ver_str_arg}" req_ver="${ver_str_arg#*=}" ;;
		branch=*)
			req_upd_channel="${ver_str_arg}" req_ver='' ;;
		[0-9]*|v[0-9]*)
			req_upd_channel=release
			req_ver="${ver_str_arg#*=}"
			req_ver="${req_ver#v}"
			;;
		*)
			upd_failed "Invalid version string '${ver_str_arg}'."
			return 1
	esac

	rm -rf "${ABL_UPD_DIR:-???}"
	try_mkdir -p "${ABL_UPD_DIR}" || { upd_failed; return 1; }

	upd_channel="${req_upd_channel:-"${ABL_UPD_CHANNEL}"}"
	upd_channel="${force_upd_channel:-"${upd_channel}"}"
	upd_channel="${upd_channel:-"release"}"

	dist_dir="${ABL_UPD_DIR}/dist"
	try_mkdir -p "${dist_dir}" || { upd_failed; return 1; }

	if [ -n "${sim_path}" ]
	then
		print_msg -yellow "Updating in simulation mode."
		[ -d "${sim_path}" ] || { upd_failed "Update simulation directory '${sim_path}' does not exist."; return 1; }
		[ -n "${ver_str_arg}" ] || { upd_failed "Specify new version string."; return 1; }
		upd_ver="${ver_str_arg}"

		[ -d "${sim_path}" ] || { upd_failed "Simulation source directory doesn't exist."; return 1; }
		cp -rT "${sim_path}" "${dist_dir}"
		log_msg "" "Updating adblock-lean to version '${upd_ver}' (update channel: '${upd_channel}')."
	else
		get_gh_ref "${upd_channel}" "${req_ver}" upd_ver tarball_url ver_type || { upd_failed; return 1; }
		case "${upd_channel}" in
			commit=*)
				# set update channel to 'commit=<full_commit_hash>'
				upd_channel="${upd_channel%=*}=${upd_ver}"
		esac
		log_msg "" "Downloading adblock-lean, ${ver_type} '${upd_ver}' (update channel: '${upd_channel}')."
		fetch_abl_dist "${tarball_url}" "${dist_dir}" || { upd_failed; return 1; }
	fi

	get_abl_version "${dist_dir}/adblock-lean"
	(
		case "${?}" in
			2)
				# no version string found - fetch latest installer script and call install_abl_files() from it
				unset tarball_url
				get_gh_ref "branch=improve_update" "" _ tarball_url _ &&
					fetch_abl_dist "${tarball_url}" "${dist_dir}/fixup" &&
					[ -f "${dist_dir}/fixup/abl-install.sh" ] ||
						{ reg_failure "Failed to fetch install script."; exit 1; }

				rm -f "${ABL_FILES_REG_PATH}"
				export pid_file="/tmp/adblock-lean/adblock-lean.pid" # for compatibility with older versions
				install_abl_files "${dist_dir}" "${upd_ver}" "${upd_channel}" "${ABL_SERVICE_PATH}" ;;
			3)
				# new version format - call install_abl_files() from fetched installer
				clean_abl_env
				# shellcheck source=/dev/null
				INST_SOURCED=1 . "${dist_dir}/abl-install.sh" ||
					{ reg_failure "Failed to source fetched install script."; exit 1; }
				install_abl_files "${dist_dir}" "${upd_ver}" "${upd_channel}" ;;
			4)
				# old version format - call install_abl_files() from fetched service file
				rm -f "${ABL_FILES_REG_PATH}"
				clean_abl_env
				# shellcheck source=/dev/null
				. "${dist_dir}/adblock-lean" ||
					{ reg_failure "Failed to source fetched script."; exit 1; }
				printf '%s\n' "${ABL_SERVICE_PATH} ${ABL_LIB_FILES} ${ABL_EXTRA_FILES}" > "${dist_dir}/inst_files"
				install_abl_files "${dist_dir}" "${upd_channel}_v${upd_ver}" ;;
			*) reg_failure "Failed to get version from fetched adblock-lean distribution."; exit 1 ;;
		esac
	) || exit 1

	log_msg -green "adblock-lean has been updated to version '${upd_ver}'."

	if [ -n "${DO_DIALOGS}" ]
	then
		print_msg "" "Start adblock-lean now? (y|n)"
		pick_opt "y|n"
		if [ "${REPLY}" = y ]
		then
			clean_abl_env
			# shellcheck source=/dev/null
			. "${ABL_SERVICE_PATH}" || return 1
			start
		fi
	fi
	:
}

uninstall()
{
	log_msg -purple "" "Uninstalling adblock-lean."
	stop -noexit
	if rc_enabled
		then
		log_msg -purple "" "Disabling adblock-lean."
		rc_disable && ! rc_enabled ||
			{ reg_failure "Failed to disable adblock-lean. Disable manually and then run this command again."; exit 1; }
	fi

	rm_cron_job

	if [ -n "${DO_DIALOGS}" ]
	then
		print_msg "" "Delete the config directory ${ABL_CONFIG_DIR}? (y|n)"
		pick_opt "y|n"
	else
		REPLY="${luci_uninstall_rm_config:-n}"
	fi

	if [ "${REPLY}" = y ]
	then
		log_msg -purple "" "Deleting the config directory."
		rm -rf "${ABL_CONFIG_DIR:-???}"
	fi

	local i="-1" addnmount_deleted=1
	while [ ${i} -lt 128 ]
	do
		i=$((i+1))
		uci -q get dhcp.@dnsmasq[${i}] >/dev/null || break
		case "$(uci -q get dhcp.@dnsmasq[${i}].addnmount)" in */bin/busybox*) ;; *) continue; esac
		addnmount_deleted=
		log_msg -purple "" "Deleting the custom addnmount entry from /etc/config/dhcp."
		if uci -q del_list dhcp.@dnsmasq[${i}].addnmount='/bin/busybox' && uci commit
		then
			case "$(uci -q get dhcp.@dnsmasq[${i}].addnmount)" in */bin/busybox*) continue; esac
			addnmount_deleted=1
			log_msg "Note: the adblock-lean developers are not aware of any other software that requires the specific addnmount entry created by adblock-lean." \
				"Should the addnmount entry be required for any reason then you will need to manually re-add it."
		fi
		break
	done
	[ -z "${addnmount_deleted}" ] &&
		reg_failure "Failed to delete the custom addnmount entry from /etc/config/dhcp. Please delete manually."

	log_msg -purple "" "Deleting the scripts."
	rm -f "${ABL_SERVICE_PATH}"
	rm -rf "${ABL_LIB_DIR}"

	log_msg -purple "" "Uninstall complete."
	exit 0
}

enable()
{
	if rc_enabled
	then
		log_msg -green "The adblock-lean service is already enabled."
		return 0
	fi
	log_msg -purple "" "Enabling the adblock-lean service."
	rc_enable && rc_enabled ||
		{ reg_failure "Failed to enable the adblock-lean service"; return 4; }
	source_libs && load_config || return 3
	[ -n "${cron_schedule}" ] && { upd_cron_job || return 6; }
	:
}

disable()
{
	local rv=0
	if rc_enabled
	then
		log_msg -purple "Disabling adblock-lean."
		rm_cron_job
		rc_disable && ! rc_enabled ||
			{ reg_failure "Failed to disable the adblock-lean service"; local rv=1; }
		stop -noexit
	else
		log_msg "The adblock-lean service is already disabled."
	fi
	return "$rv"
}

set_ansi

# test process substitution support
printf '%s\n%s\n' "#!/bin/sh" "printf %s >(:)" > /tmp/abl-test
if ! /bin/sh /tmp/abl-test 1>/dev/null 2>/dev/null
then
	rm -f /tmp/abl-test
	reg_failure "This shell does not support process substitution. To use adblock-lean, please update OpenWrt to 22.03 or later version."
	exit 1
fi
rm -f /tmp/abl-test

detect_utils

# register 1st arg as $ABL_CMD when called by 'sh /etc/init.d/adblock-lean'
if [ "${0}" = "${ABL_SERVICE_PATH}" ]
then
	ABL_CMD="${1}"
	shift
fi

# shellcheck source=/dev/null
# this is needed when running via 'sh /etc/init.d/adblock-lean'
check_func config_load 1>/dev/null || . /lib/functions.sh || { reg_failure "Failed to source /lib/functions.sh"; exit 1; }

# detect when sourced from update() in older versions
check_func failsafe_log 1>/dev/null && UPD_SOURCED=1

case "${ABL_CMD}" in
	enable|disable|uninstall|update|setup) ${ABL_CMD} "${@}"; exit ${?} ;;
esac

:
